<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>OpenAI Codex ç‰©ç†é€»è¾‘è§†è§’æ·±åº¦è§£è¯»</title>
    <style>
        body {
            font-family: 'SimSun', 'å®‹ä½“', Arial, sans-serif; /* A4å¸¸ç”¨å®‹ä½“ï¼Œè¾…ä»¥Arial */
            font-size: 16pt; /* ä¸‰å·å­—ä½“å¤§çº¦ä¸º16pt */
            line-height: 1.8; /* å¢åŠ è¡Œé«˜ä»¥ä¾¿é˜…è¯» */
            margin: 0 auto;
            padding: 25mm 20mm; /* æ¨¡æ‹ŸA4é¡µè¾¹è· (ä¸Šä¸‹25mmï¼Œå·¦å³20mm) */
            background-color: #f0f0f0; /* æµ…ç°è‰²èƒŒæ™¯ */
            color: #333;
            max-width: 210mm; /* A4å®½åº¦ */
            min-height: 297mm; /* A4é«˜åº¦ï¼Œç¡®ä¿å†…å®¹åŒºåŸŸè‡³å°‘æœ‰A4é«˜ */
            box-sizing: border-box;
        }
        .container {
            background-color: #fff;
            padding: 20mm; /* å†…å®¹åŒºåŸŸå†…è¾¹è· */
            border: 1px solid #ccc;
            box-shadow: 0 0 15px rgba(0,0,0,0.15);
            min-height: calc(297mm - 50mm - 2px); /* ç¡®ä¿ç™½è‰²å†…å®¹åŒºåŸŸå¡«æ»¡ */
        }
        h1, h2, h3 {
            color: #1a237e; /* æ·±è“è‰²æ ‡é¢˜ */
            border-bottom: 3px solid #3949ab; /* ç¨æ·±çš„è“è‰²ä¸‹åˆ’çº¿ */
            padding-bottom: 8px;
            margin-top: 1.5em; /* å¢åŠ æ ‡é¢˜ä¸Šè¾¹è· */
            margin-bottom: 0.8em;
        }
        h1 {
            text-align: center;
            font-size: 26pt; /* ç¨å¤§çš„ä¸€å·æ ‡é¢˜ */
            margin-bottom: 1.2em;
        }
        h2 {
            font-size: 20pt;
        }
        h3 {
            font-size: 18pt;
        }
        p {
            text-indent: 2em; /* æ®µé¦–ç¼©è¿›ä¸¤ä¸ªå­—ç¬¦ */
            margin-bottom: 1em;
            text-align: justify; /* ä¸¤ç«¯å¯¹é½ï¼Œæ›´ç¬¦åˆæ­£å¼æ–‡æ¡£ */
        }
        .formula {
            font-family: 'Consolas', 'Courier New', Courier, monospace; /* ç­‰å®½å­—ä½“æ˜¾ç¤ºå…¬å¼ */
            background-color: #e8eaf6; /* æ·¡ç´«è‰²èƒŒæ™¯ */
            padding: 3px 6px;
            border-radius: 4px;
            display: inline-block;
            color: #333;
        }
        canvas {
            border: 1px solid #9fa8da; /* æ·¡ç´«è‰²è¾¹æ¡† */
            margin: 20px auto;
            display: block;
            background-color: #fdfdff; /* éå¸¸æµ…çš„èƒŒæ™¯è‰² */
            border-radius: 4px;
        }
        .controls {
            text-align: center;
            margin-bottom: 25px;
            margin-top: 10px;
        }
        .controls button {
            padding: 12px 20px;
            font-size: 14pt; /* æŒ‰é’®å­—ä½“ç¨å° */
            margin: 0 8px;
            cursor: pointer;
            background-color: #3949ab; /* ä¸»é¢˜è“è‰² */
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .controls button:hover {
            background-color: #283593; /* æ·±ä¸€ç‚¹çš„è“è‰² */
        }
        .controls button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
        }
        .tabs button {
            flex-grow: 1;
            max-width: 220px; /* æ ‡ç­¾æŒ‰é’®å®½åº¦ */
        }
        .tab-content {
            padding: 20px;
            border: 1px dashed #9fa8da;
            min-height: 120px;
            text-align: left; /* å†…å®¹å·¦å¯¹é½ */
            font-size: 14pt;
            background-color: #f5f5ff; /* æ ‡ç­¾å†…å®¹åŒºåŸŸèƒŒæ™¯ */
            border-radius: 4px;
            white-space: pre-wrap; /* ä¿ç•™æ¢è¡Œå’Œç©ºæ ¼ */
        }
        .caption {
            text-align: center;
            font-style: italic;
            font-size: 13pt;
            color: #555;
            margin-top: -10px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>OpenAI Codexï¼šç‰©ç†é€»è¾‘è§†è§’çš„æ·±åº¦å‰–æ</h1>

        <h2>ä¸€ã€å¼•è¨€ï¼šä»£ç ç”Ÿæˆçš„â€œç‰©ç†â€å˜é©</h2>
        <p>OpenAI Codexçš„é—®ä¸–ï¼Œä»£è¡¨äº†äººå·¥æ™ºèƒ½åœ¨ç†è§£è‡ªç„¶è¯­è¨€å¹¶å°†å…¶è½¬åŒ–ä¸ºå¯æ‰§è¡Œä»£ç æ–¹é¢çš„ä¸€åº§é‡Œç¨‹ç¢‘ã€‚å®ƒä¸ä»…æ˜¯ç¼–ç¨‹çš„è¾…åŠ©å·¥å…·ï¼Œæ›´æ˜¯ä¸€ä¸ªæ·±åˆ»æ”¹å˜äººæœºäº¤äº’æ¨¡å¼çš„å‚¬åŒ–å‰‚ã€‚æœ¬æ–‡æ—¨åœ¨ä»â€œç‰©ç†é€»è¾‘â€çš„ç‹¬ç‰¹è§†è§’ï¼Œå®¡è§†Codexçš„è¿ä½œæœºç†ã€‚è¿™é‡Œçš„â€œç‰©ç†é€»è¾‘â€å¹¶éæŒ‡ä»£ç»å…¸ç‰©ç†å­¦å®šå¾‹ï¼Œè€Œæ˜¯å¼ºè°ƒæ„æˆCodexç³»ç»Ÿè¿ä½œçš„å®é™…è®¡ç®—æµç¨‹ã€æ•°æ®åœ¨ç³»ç»Ÿå†…éƒ¨çš„è½¬æ¢è·¯å¾„ã€ä¿¡æ¯å¤„ç†çš„å…·ä½“æœºåˆ¶ï¼Œä»¥åŠå…¶å†…éƒ¨å¯è¢«è§‚å¯Ÿå’Œåˆ†æçš„ã€å…·æœ‰ç¡®å®šæ€§çš„å› æœå…³ç³»é“¾æ¡ã€‚æˆ‘ä»¬å°†Codexè§†ä¸ºä¸€ä¸ªå¤æ‚çš„â€œä¿¡æ¯å¤„ç†æœºå™¨â€ï¼Œæ¢ç©¶å…¶å¦‚ä½•å°†æŠ½è±¡çš„äººç±»æ„å›¾â€œç‰©åŒ–â€ä¸ºç²¾ç¡®çš„ä»£ç ç»“æ„ã€‚</p>

        <h2>äºŒã€Codexçš„æ ¸å¿ƒå¼•æ“ï¼šGPTæ¨¡å‹çš„â€œç‰©ç†â€åŸºçŸ³</h2>
        <p>Codexçš„å¼ºå¤§èƒ½åŠ›æ ¹æ¤äºOpenAIçš„GPTï¼ˆGenerative Pre-trained Transformerï¼‰ç³»åˆ—æ¨¡å‹ï¼Œå¹¶é’ˆå¯¹ä»£ç ä»»åŠ¡è¿›è¡Œäº†æ·±åº¦ä¼˜åŒ–ã€‚å…¶ç‰©ç†é€»è¾‘åŸºç¡€å¯æ¦‚æ‹¬ä¸ºï¼š</p>
        <ol>
            <li><strong>åºå¤§çš„ç¥ç»ç½‘ç»œç»“æ„ï¼š</strong> Codexæœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªç”±æµ·é‡å‚æ•°ï¼ˆæ•°åäº¿ä¹ƒè‡³æ›´å¤šï¼‰æ„æˆçš„æ·±åº¦ç¥ç»ç½‘ç»œã€‚è¿™äº›å‚æ•°ï¼ˆæƒé‡å’Œåç½®ï¼‰å¦‚åŒä¸€ä¸ªå·¨å¤§ä¸”ç²¾å¯†çš„â€œç”µè·¯æ¿â€ï¼Œåœ¨è®­ç»ƒè¿‡ç¨‹ä¸­è¢«ç²¾å¿ƒâ€œèš€åˆ»â€å’Œâ€œè¿æ¥â€ï¼Œä»¥ç¼–ç ä»æ•°æ®ä¸­å­¦ä¹ åˆ°çš„å¤æ‚æ¨¡å¼ã€‚å…¶ç‰©ç†å½¢æ€å³æ˜¯å­˜å‚¨äºé«˜ç«¯è®¡ç®—èŠ¯ç‰‡ï¼ˆå¦‚GPU/TPUï¼‰ä¸­çš„å·¨é‡æ•°å€¼ã€‚</li>
            <li><strong>æµ·é‡è®­ç»ƒæ•°æ®â€”â€”å¡‘é€ æ¨¡å‹çš„â€œåŸææ–™â€ï¼š</strong> Codexçš„â€œæ™ºèƒ½â€æ¥æºäºå¯¹å·¨é‡æ–‡æœ¬å’Œå…¬å¼€æºä»£ç ï¼ˆä¾‹å¦‚GitHubä¸Šçš„æ•°åäº¿è¡Œä»£ç ï¼‰çš„â€œæ¶ˆåŒ–å¸æ”¶â€ã€‚è¿™äº›æ•°æ®æ„æˆäº†æ¨¡å‹æ„å»ºå…¶å†…éƒ¨è¡¨å¾çš„â€œç‰©ç†åŸææ–™â€ã€‚è®­ç»ƒè¿‡ç¨‹å¯ä»¥ç†è§£ä¸ºä¸€ç§ç»Ÿè®¡è§„å¾‹çš„æå–ã€å‹ç¼©ä¸â€œå›ºåŒ–â€ï¼Œå…¶æ€§èƒ½å¯ç²—ç•¥è¡¨è¿°ä¸ºï¼š<span class="formula">æ¨¡å‹æ•ˆèƒ½ = F(ç½‘ç»œè§„æ¨¡, æ•°æ®è´¨é‡ä¸æ•°é‡, è®¡ç®—èµ„æº)</span>ã€‚</li>
            <li><strong>Transformeræ¶æ„â€”â€”ä¿¡æ¯æµåŠ¨çš„â€œç®¡é“ç³»ç»Ÿâ€ï¼š</strong> Transformeræ¨¡å‹ç‰¹æœ‰çš„è‡ªæ³¨æ„åŠ›æœºåˆ¶ï¼ˆSelf-Attention Mechanismï¼‰æ˜¯å…¶æ ¸å¿ƒã€‚å®ƒå…è®¸æ¨¡å‹åœ¨å¤„ç†è¾“å…¥åºåˆ—æ—¶ï¼ŒåŠ¨æ€è¯„ä¼°ä¸åŒéƒ¨åˆ†ä¹‹é—´çš„ç›¸å…³æ€§ä¸é‡è¦æ€§ï¼Œä»è€Œæ•æ‰é•¿è·ç¦»ä¾èµ–ã€‚åœ¨ç‰©ç†é€»è¾‘ä¸Šï¼Œè¿™ç›¸å½“äºä¸€ä¸ªé«˜æ•ˆçš„ã€å¯å¹¶è¡Œçš„ä¿¡æ¯ç­›é€‰ã€åŠ æƒä¸æ•´åˆç³»ç»Ÿã€‚è¾“å…¥ä¿¡æ¯ <span class="formula">X</span> åœ¨æµç»å¤šå±‚å¤„ç†å•å…ƒæ—¶ï¼Œæ¯ä¸€å±‚éƒ½é€šè¿‡æ³¨æ„åŠ›è®¡ç®— <span class="formula">Attention(Q, K, V) = softmax(Q * K^T / sqrt(d_k)) * V</span> æ¥æ›´æ–°å’Œæç‚¼ä¿¡æ¯çš„è¡¨ç¤ºï¼Œç¡®ä¿å…³é”®ä¿¡æ¯åœ¨å¤æ‚çš„â€œç®¡é“ç½‘ç»œâ€ä¸­å¾—åˆ°æœ‰æ•ˆä¼ é€’å’Œæ”¾å¤§ã€‚</li>
        </ol>
        <p>è¿™ç§ç²¾å¯†çš„â€œç‰©ç†æ„é€ â€ä½¿å¾—Codexèƒ½å¤Ÿåœ¨å…¶å†…éƒ¨å»ºç«‹ä»è‡ªç„¶è¯­è¨€çš„æ¨¡ç³Šè¯­ä¹‰åˆ°ä»£ç çš„ç²¾ç¡®è¯­æ³•çš„æ˜ å°„å…³ç³»ã€‚</p>
        <div class="controls">
            <button id="playNlToCode">åŠ¨ç”»1: è‡ªç„¶è¯­è¨€åˆ°ä»£ç çš„è½¬æ¢</button>
        </div>
        <canvas id="nlToCodeCanvas" width="600" height="200"></canvas>
        <p class="caption">å›¾1ï¼šè‡ªç„¶è¯­è¨€æŒ‡ä»¤é€šè¿‡Codexæ ¸å¿ƒå¤„ç†è½¬åŒ–ä¸ºä»£ç çš„è¿‡ç¨‹ç¤ºæ„ã€‚</p>

        <h2>ä¸‰ã€Codexçš„å·¥ä½œæœºç†ï¼šæŒ‡ä»¤åˆ°ä»£ç çš„â€œç‰©ç†è·¯å¾„â€</h2>
        <p>å½“ç”¨æˆ·å‘Codexå‘å‡ºä¸€æ¡è‡ªç„¶è¯­è¨€æŒ‡ä»¤ï¼ˆä¾‹å¦‚ï¼šâ€œç”¨Pythonå†™ä¸€ä¸ªå‡½æ•°ï¼Œè®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—çš„ç¬¬nä¸ªæ•°â€ï¼‰æ—¶ï¼Œç³»ç»Ÿå†…éƒ¨ç»å†äº†ä¸€ç³»åˆ—å¯è¿½æº¯çš„â€œç‰©ç†é€»è¾‘â€æ­¥éª¤ï¼š</p>
        <p><strong>1. è¾“å…¥è§£æä¸ç¼–ç  (Input Parsing & Encoding):</strong> è‡ªç„¶è¯­è¨€æŒ‡ä»¤é¦–å…ˆè¢«åˆ†è§£ä¸ºä¸€ç³»åˆ—ç§°ä¸ºâ€œtokensâ€ï¼ˆè¯å…ƒï¼‰çš„åŸºæœ¬å•å…ƒã€‚è¿™äº›tokenséšåè¢«è½¬æ¢ä¸ºé«˜ç»´çš„æ•°å­—å‘é‡ï¼ˆembeddingsï¼‰ï¼Œè¿™æ˜¯æ¨¡å‹èƒ½å¤Ÿè¿›è¡Œæ•°å­¦è¿ç®—çš„â€œç‰©ç†å½¢æ€â€ã€‚æ­¤è¿‡ç¨‹ç±»ä¼¼äºå°†å£°æ³¢ï¼ˆè¯­éŸ³æŒ‡ä»¤ï¼‰æˆ–å…‰ä¿¡å·ï¼ˆæ–‡æœ¬è¾“å…¥ï¼‰è½¬æ¢ä¸ºå¯åœ¨ç”µå­ç”µè·¯ä¸­å¤„ç†çš„æ•°å­—ç”µä¿¡å·ã€‚</p>
        <p><strong>2. ä¸Šä¸‹æ–‡ç†è§£ä¸æ¨¡å¼åŒ¹é… (Contextual Understanding & Pattern Matching):</strong> è¿™äº›è¾“å…¥å‘é‡ä½œä¸ºâ€œåˆå§‹æ¿€åŠ±ä¿¡å·â€æµç»Transformerç½‘ç»œçš„å¤šä¸ªå±‚é¢ã€‚åœ¨æ¯ä¸€å±‚ï¼Œè‡ªæ³¨æ„åŠ›æœºåˆ¶å’Œå‰é¦ˆç½‘ç»œå…±åŒä½œç”¨ï¼Œå¯¹è¾“å…¥ä¿¡æ¯è¿›è¡Œå¤æ‚çš„éçº¿æ€§å˜æ¢ã€‚æ¨¡å‹åœ¨å…¶å·¨å¤§çš„å‚æ•°ç©ºé—´ä¸­ï¼ˆå³è¢«è®­ç»ƒå›ºåŒ–çš„â€œç‰©ç†ç»“æ„â€ä¸­ï¼‰æœå¯»ä¸è¾“å…¥æŒ‡ä»¤æœ€ç›¸å…³çš„æ¨¡å¼ã€‚è¿™å¹¶éäººç±»æ„ä¹‰ä¸Šçš„â€œç†è§£â€ï¼Œè€Œæ˜¯ä¸€ç§åŸºäºå…¶è®­ç»ƒæ•°æ®çš„é«˜åº¦å¤æ‚çš„ç»Ÿè®¡å…³è”ä¸â€œæ¨¡å¼è°æŒ¯â€ã€‚</p>
        <p><strong>3. ä»£ç ç”Ÿæˆä¸è§£ç  (Code Generation & Decoding):</strong> æ¨¡å‹ä»¥è‡ªå›å½’çš„æ–¹å¼é€ä¸ªtokenç”Ÿæˆè¾“å‡ºä»£ç ã€‚å³ï¼Œæ¯ç”Ÿæˆä¸€ä¸ªtokenï¼Œè¿™ä¸ªtokenå°±ä¼šæˆä¸ºä¸‹ä¸€æ­¥ç”Ÿæˆè¿‡ç¨‹çš„è¾“å…¥ä¹‹ä¸€ï¼Œå½±å“åç»­tokençš„â€œæ¿€å‘æ¦‚ç‡â€ã€‚æ¨¡å‹åœ¨æ¯ä¸ªæ­¥éª¤è®¡ç®—è¯æ±‡è¡¨ä¸­æ‰€æœ‰å¯èƒ½tokençš„æ¦‚ç‡åˆ†å¸ƒï¼Œå¹¶é€šå¸¸é€‰æ‹©æ¦‚ç‡æœ€é«˜çš„tokenï¼ˆæˆ–é€šè¿‡é‡‡æ ·å¼•å…¥ä¸€å®šçš„éšæœºæ€§ï¼Œæ¢ç´¢ä¸åŒçš„â€œç‰©ç†è·¯å¾„â€ï¼‰ã€‚è¿™ä¸ªè¿‡ç¨‹å¯ä»¥è¢«è§†ä¸ºä¸€ä¸ªå—æ§çš„ã€æ¦‚ç‡æ€§çš„åºåˆ—å†³ç­–è¿‡ç¨‹ï¼Œå…¶ç›®æ ‡æ˜¯æ„å»ºä¸€ä¸ªåœ¨è¯­æ³•ä¸Šæ­£ç¡®ä¸”åœ¨åŠŸèƒ½ä¸Šç¬¦åˆè¾“å…¥æŒ‡ä»¤çš„â€œç¨³å®šè¾“å‡ºåºåˆ—â€ã€‚</p>
        <div class="controls">
            <button id="playGptFlow">åŠ¨ç”»2: GPTæ¨¡å‹å†…éƒ¨å¤„ç†æµç¨‹</button>
        </div>
        <canvas id="gptFlowCanvas" width="700" height="300"></canvas>
        <p class="caption">å›¾2ï¼šç®€åŒ–å±•ç¤ºçš„GPTæ¨¡å‹å†…éƒ¨ä¿¡æ¯æµåŠ¨ä¸å¤„ç†å±‚æ¬¡ã€‚</p>

        <h2>å››ã€Codexçš„èƒ½åŠ›ã€åº”ç”¨ä¸â€œç‰©ç†â€å±€é™</h2>
        <p>Codexå±•ç°äº†å¼ºå¤§çš„ä»£ç ç”Ÿæˆã€è¡¥å…¨ã€è§£é‡Šã€é‡æ„ç”šè‡³è·¨è¯­è¨€ç¿»è¯‘èƒ½åŠ›ã€‚è¿™äº›èƒ½åŠ›æ˜¯å…¶å¤æ‚â€œç‰©ç†ç»“æ„â€ä¸æµ·é‡æ•°æ®è®­ç»ƒåæ¶Œç°å‡ºçš„å®è§‚è¡¨ç°ã€‚</p>
        <h3>4.1 èƒ½åŠ›å±•ç¤ºï¼ˆäº¤äº’å¼ï¼‰</h3>
        <div class="tabs">
            <button class="tab-button" onclick="showCapability('gen_python_class')">ç”ŸæˆPythonç±»</button>
            <button class="tab-button" onclick="showCapability('explain_regex')">è§£é‡Šæ­£åˆ™è¡¨è¾¾å¼</button>
            <button class="tab-button" onclick="showCapability('convert_sql_pandas')">SQLè½¬Pandas</button>
        </div>
        <div id="capabilityDisplay" class="tab-content">
            ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®æŸ¥çœ‹Codexèƒ½åŠ›ç¤ºä¾‹... (ä¾‹å¦‚ï¼Œå®ƒå¯ä»¥æ ¹æ®æè¿°ç”Ÿæˆå¤æ‚çš„ç±»ç»“æ„ï¼Œè§£é‡Šéš¾ä»¥ç†è§£çš„ä»£ç ç‰‡æ®µï¼Œæˆ–åœ¨ä¸åŒç¼–ç¨‹èŒƒå¼é—´è½¬æ¢é€»è¾‘ã€‚)
        </div>
        <p class="caption">å›¾3ï¼šCodexåœ¨ä¸åŒç¼–ç¨‹ä»»åŠ¡ä¸­çš„åº”ç”¨ç¤ºä¾‹ã€‚</p>
        <h3>4.2 ç‰©ç†é€»è¾‘å±‚é¢çš„å±€é™æ€§</h3>
        <p>å°½ç®¡åŠŸèƒ½å¼ºå¤§ï¼ŒCodexçš„â€œç‰©ç†é€»è¾‘â€åŸºç¡€ä¹Ÿå†³å®šäº†å…¶å›ºæœ‰çš„å±€é™æ€§ï¼š</p>
        <ol>
            <li><strong>çŸ¥è¯†è¾¹ç•Œçš„â€œç‰©ç†â€çº¦æŸï¼š</strong> Codexçš„çŸ¥è¯†ä¸¥æ ¼å—é™äºå…¶è®­ç»ƒæ•°æ®é›†çš„â€œæ—¶ç©ºèŒƒå›´â€ã€‚å®ƒæ— æ³•åˆ›é€ å‡ºè®­ç»ƒæ•°æ®ä¸­ä»æœªæš—ç¤ºè¿‡çš„å…¨æ–°ç®—æ³•æˆ–ç¼–ç¨‹èŒƒå¼ã€‚å…¶â€œåˆ›é€ åŠ›â€æ›´å¤šæ˜¯å¯¹ç°æœ‰æ¨¡å¼çš„å·§å¦™ç»„åˆä¸â€œæ’å€¼â€ï¼Œè€ŒéçœŸæ­£çš„â€œä»æ— åˆ°æœ‰â€çš„ç‰©ç†åˆ›é€ ã€‚</li>
            <li><strong>ç¼ºä¹çœŸå®ä¸–ç•Œæ„ŸçŸ¥ä¸æ·±åº¦å› æœæ¨ç†ï¼š</strong> Codexä¸å…·å¤‡å¯¹ä»£ç æ‰§è¡Œçš„çœŸå®ç‰©ç†åæœï¼ˆå¦‚æ€§èƒ½ç“¶é¢ˆçš„æ·±å±‚åŸå› ã€ç‰¹å®šç¡¬ä»¶çš„äº¤äº’ã€çœŸå®ä¸–ç•Œçš„å¤æ‚çº¦æŸï¼‰çš„ç†è§£ã€‚å®ƒç”Ÿæˆçš„ä»£ç å¯èƒ½è¯­æ³•æ­£ç¡®ï¼Œä½†åœ¨ç‰¹å®šä¸Šä¸‹æ–‡ä¸­æ•ˆç‡ä½ä¸‹æˆ–å­˜åœ¨å®‰å…¨éšæ‚£ï¼Œå› ä¸ºå®ƒä¸»è¦ä¾èµ–ç»Ÿè®¡æ¨¡å¼è€Œéå¯¹é—®é¢˜æœ¬è´¨çš„å› æœåˆ†æã€‚å…¶å†³ç­–å…¬å¼æ›´æ¥è¿‘ <span class="formula">Output = P(Input | ModelParameters)</span> è€Œé <span class="formula">Output = Logic(Input, WorldKnowledge, Constraints)</span>ã€‚</li>
            <li><strong>æ¦‚ç‡æ€§é”™è¯¯ä¸â€œè²Œåˆç¥ç¦»â€çš„è¾“å‡ºï¼š</strong> ç”±äºå…¶æ¦‚ç‡ç”Ÿæˆçš„æœ¬è´¨ï¼ŒCodexæœ‰æ—¶ä¼šç”Ÿæˆçœ‹ä¼¼åˆç†ä½†å®é™…ä¸Šé”™è¯¯æˆ–æ— ç”¨çš„ä»£ç ï¼Œå³æ‰€è°“çš„â€œå¹»è§‰â€(hallucination)ã€‚è¿™æ˜¯å…¶â€œç‰©ç†ç³»ç»Ÿâ€åœ¨é¢å¯¹æ¨¡ç³Šæˆ–æœªè§è¿‡çš„è¾“å…¥æ—¶ï¼Œå¯èƒ½é™·å…¥çš„â€œå±€éƒ¨æœ€ä¼˜â€æˆ–â€œè™šå‡ç¨³å®šæ€â€ã€‚</li>
        </ol>
        <div class="controls">
            <button id="playBlackBox">åŠ¨ç”»4: AIçš„â€œé»‘ç®±â€ä¸æ¦‚ç‡è¾“å‡º</button>
        </div>
        <canvas id="blackBoxCanvas" width="600" height="250"></canvas>
        <p class="caption">å›¾4ï¼šAIæ¨¡å‹çš„é»‘ç®±ç‰¹æ€§åŠè¾“å‡ºçš„æ¦‚ç‡æ€§é€‰æ‹©è¿‡ç¨‹ã€‚</p>

        <h2>äº”ã€Codexä¸å¼€å‘è€…çš„ååŒï¼šâ€œäººæœºç‰©ç†ç³»ç»Ÿâ€</h2>
        <p>Codexå¹¶éæ—¨åœ¨å–ä»£å¼€å‘è€…ï¼Œè€Œæ˜¯ä½œä¸ºä¸€ç§å¼ºå¤§çš„ååŒå·¥å…·ï¼Œä¸å¼€å‘è€…å…±åŒæ„æˆä¸€ä¸ªæ›´é«˜æ•ˆçš„â€œäººæœºç‰©ç†ç³»ç»Ÿâ€ã€‚ç†æƒ³çš„å·¥ä½œæµç¨‹æ˜¯ï¼š</p>
        <ol>
            <li>å¼€å‘è€…æä¾›æ¸…æ™°ã€ç»“æ„åŒ–çš„è‡ªç„¶è¯­è¨€æŒ‡ä»¤æˆ–åˆæ­¥ä»£ç æ¡†æ¶ï¼ˆè¾“å…¥â€œèƒ½é‡â€ä¸â€œå¯¼å‘â€ï¼‰ã€‚</li>
            <li>Codexæ ¹æ®æŒ‡ä»¤å¿«é€Ÿç”Ÿæˆå€™é€‰ä»£ç ç‰‡æ®µï¼ˆç³»ç»Ÿâ€œå“åº”â€ä¸â€œåˆæ­¥æ„å»ºâ€ï¼‰ã€‚</li>
            <li>å¼€å‘è€…å®¡æŸ¥ã€æµ‹è¯•ã€ä¿®æ”¹å’Œå®Œå–„Codexç”Ÿæˆçš„ä»£ç ï¼ˆâ€œåé¦ˆè°ƒèŠ‚â€ä¸â€œç²¾ç¡®æ ¡å‡†â€ï¼‰ã€‚</li>
            <li>é€šè¿‡è¿­ä»£åé¦ˆï¼Œäººæœºç³»ç»Ÿå…±åŒå°†è§£å†³æ–¹æ¡ˆæ¨å‘ä¼˜åŒ–ï¼ˆç³»ç»Ÿâ€œæ¼”åŒ–â€ä¸â€œç¨³å®šâ€ï¼‰ã€‚</li>
        </ol>
        <div class="controls">
            <button id="playWorkflow">åŠ¨ç”»5: å¼€å‘è€…ä¸Codexçš„è¿­ä»£å·¥ä½œæµ</button>
        </div>
        <canvas id="workflowCanvas" width="700" height="250"></canvas>
        <p class="caption">å›¾5ï¼šå¼€å‘è€…ä¸CodexååŒå·¥ä½œçš„è¿­ä»£æµç¨‹ç¤ºæ„ã€‚</p>

        <h2>å…­ã€ç»“è®ºï¼šé©¾é©­ä»£ç ç”Ÿæˆçš„â€œç‰©ç†â€ä¹‹åŠ›</h2>
        <p>OpenAI Codexæ˜¯äººå·¥æ™ºèƒ½åœ¨ä»£ç ç†è§£ä¸ç”Ÿæˆé¢†åŸŸå–å¾—çš„å“è¶Šæˆå°±ã€‚ä»ç‰©ç†é€»è¾‘è§†è§’çœ‹ï¼Œå…¶æ ¸å¿ƒåœ¨äºå¤§è§„æ¨¡ç¥ç»ç½‘ç»œé€šè¿‡å­¦ä¹ æµ·é‡æ•°æ®æ¨¡å¼è€Œå½¢æˆçš„ç‰¹å®šâ€œç‰©ç†é…ç½®â€ã€‚å®ƒé€šè¿‡ä¸€ç³»åˆ—å¤æ‚çš„ã€ç¡®å®šæ€§çš„ï¼ˆåœ¨ç»™å®šæ¨¡å‹å’Œè¾“å…¥æ—¶ï¼‰è®¡ç®—æ­¥éª¤ï¼Œå°†äººç±»çš„è‡ªç„¶è¯­è¨€æ„å›¾â€œç¿»è¯‘â€å¹¶â€œç‰©åŒ–â€ä¸ºæœºå™¨å¯æ‰§è¡Œçš„ä»£ç ã€‚ç†è§£å…¶ä½œä¸ºä¸€ç§åŸºäºç»Ÿè®¡æ¨¡å¼åŒ¹é…è€ŒéçœŸæ­£é€»è¾‘æ¨ç†çš„ç³»ç»Ÿæœ¬è´¨ï¼Œè®¤è¯†åˆ°å…¶ä¾èµ–è®­ç»ƒæ•°æ®ã€ç¼ºä¹çœŸå®ä¸–ç•Œæ„ŸçŸ¥ä»¥åŠæ½œåœ¨çš„æ¦‚ç‡æ€§é”™è¯¯ç­‰â€œç‰©ç†å±€é™â€ï¼Œå¯¹äºæˆ‘ä»¬å®‰å…¨ã€æœ‰æ•ˆåœ°é©¾é©­è¿™ä¸€å¼ºå¤§çš„â€œä»£ç ç”Ÿæˆå¼•æ“â€è‡³å…³é‡è¦ã€‚æœªæ¥ï¼Œäººç±»å¼€å‘è€…ä¸Codexç­‰AIç³»ç»Ÿçš„ååŒè¿›åŒ–ï¼Œå°†åœ¨ä¸æ–­æ¢ç´¢å’Œå¡‘é€ æ–°çš„è®¡ç®—â€œç‰©ç†é€»è¾‘â€è¾¹ç•Œä¸­ï¼Œå…±åŒæ¨åŠ¨è½¯ä»¶å·¥ç¨‹çš„é©æ–°ä¸å‘å±•ã€‚</p>
    </div>

    <script>
        // Animation 1: Natural Language to Code Transformation
        const canvasNlToCode = document.getElementById('nlToCodeCanvas');
        const ctxNlToCode = canvasNlToCode.getContext('2d');
        let nlToCodeAnimationId;
        let nlText = "åˆ›å»ºè“è‰²æŒ‰é’®"; // Shorter text
        let codeText = "<button class='blue'>Click</button>"; // Simplified code
        let progressNlToCode = 0;
        let particlesNlToCode = [];

        function initNlToCodeParticles() {
            particlesNlToCode = [];
            for (let i = 0; i < 50; i++) {
                particlesNlToCode.push({
                    x: canvasNlToCode.width / 4 + Math.random() * 20 - 10,
                    y: canvasNlToCode.height / 2 + Math.random() * 20 - 10,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    targetX: canvasNlToCode.width * 0.75 + Math.random() * 20 - 10,
                    targetY: canvasNlToCode.height / 2 + Math.random() * 20 - 10,
                    size: Math.random() * 2 + 1,
                    color: `rgba(57, 73, 171, ${Math.random() * 0.5 + 0.3})` // Shades of indigo
                });
            }
        }

        function drawNlToCode() {
            ctxNlToCode.clearRect(0, 0, canvasNlToCode.width, canvasNlToCode.height);
            ctxNlToCode.font = "bold 20px 'SimSun'";
            ctxNlToCode.textAlign = "center";

            // Draw NL text
            ctxNlToCode.fillStyle = "#3949ab";
            ctxNlToCode.fillText(nlText, canvasNlToCode.width / 4, canvasNlToCode.height / 2 + 8);

            // Draw "Codex Core" (abstract representation)
            const coreX = canvasNlToCode.width / 2;
            const coreY = canvasNlToCode.height / 2;
            const coreRadius = 40 + 10 * Math.sin(progressNlToCode * Math.PI * 2);
            ctxNlToCode.beginPath();
            ctxNlToCode.arc(coreX, coreY, coreRadius, 0, Math.PI * 2);
            ctxNlToCode.fillStyle = `rgba(121, 134, 203, ${0.5 + 0.3 * Math.sin(progressNlToCode * Math.PI * 4)})`; // Pulsing indigo
            ctxNlToCode.fill();
            ctxNlToCode.strokeStyle = "#3949ab";
            ctxNlToCode.lineWidth = 2;
            ctxNlToCode.stroke();
            ctxNlToCode.fillStyle = "white";
            ctxNlToCode.font = "bold 14px 'SimSun'";
            ctxNlToCode.fillText("Codex", coreX, coreY + 5);


            // Draw particles moving if in progress
            if (progressNlToCode > 0.1 && progressNlToCode < 0.9) {
                particlesNlToCode.forEach(p => {
                    if (progressNlToCode > 0.2) { // Start moving towards target
                        p.x += (p.targetX - p.x) * 0.05;
                        p.y += (p.targetY - p.y) * 0.05;
                    } else { // Initial burst
                        p.x += p.vx;
                        p.y += p.vy;
                    }
                    ctxNlToCode.beginPath();
                    ctxNlToCode.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctxNlToCode.fillStyle = p.color;
                    ctxNlToCode.fill();
                });
            }
            
            // Draw Code text appearing
            ctxNlToCode.globalAlpha = Math.max(0, (progressNlToCode - 0.7) / 0.3);
            ctxNlToCode.fillStyle = "#2E7D32"; // Dark Green for code
            ctxNlToCode.font = "bold 18px 'Consolas', monospace";
            ctxNlToCode.fillText(codeText, canvasNlToCode.width * 0.75, canvasNlToCode.height / 2 + 8);
            ctxNlToCode.globalAlpha = 1;

            if (progressNlToCode < 1) {
                progressNlToCode += 0.01;
                nlToCodeAnimationId = requestAnimationFrame(drawNlToCode);
            }
        }

        document.getElementById('playNlToCode').addEventListener('click', () => {
            cancelAnimationFrame(nlToCodeAnimationId);
            progressNlToCode = 0;
            initNlToCodeParticles();
            drawNlToCode();
        });
        initNlToCodeParticles(); // Initial setup
        drawNlToCode(); // Initial draw

        // Animation 2: Simplified GPT Internal Flow
        const canvasGptFlow = document.getElementById('gptFlowCanvas');
        const ctxGptFlow = canvasGptFlow.getContext('2d');
        let gptFlowAnimationId;
        let gptFlowProgress = 0;
        const gptLayers = [
            { name: "è¾“å…¥ Tokens", x: 100, y: 150, type: "input", active: 0 },
            { name: "Embedding", x: 220, y: 150, type: "layer", active: 0 },
            { name: "Transformerå— 1", x: 340, y: 150, type: "transformer", active: 0 },
            { name: "Transformerå— N", x: 460, y: 150, type: "transformer", active: 0 },
            { name: "è¾“å‡ºè§£ç ", x: 580, y: 150, type: "layer", active: 0 }
        ];
        let dataPackets = [];

        function initGptFlowPackets() {
            dataPackets = [];
            for(let i=0; i<3; i++) { // Create 3 packets
                 dataPackets.push({
                    currentLayer: 0,
                    x: gptLayers[0].x,
                    y: gptLayers[0].y - 15 + i*15,
                    targetX: gptLayers[0].x,
                    targetY: gptLayers[0].y - 15 + i*15,
                    progress: 0,
                    color: `hsl(${i * 60 + 180}, 70%, 60%)` // Different colors
                });
            }
        }

        function drawGptFlow() {
            ctxGptFlow.clearRect(0, 0, canvasGptFlow.width, canvasGptFlow.height);
            ctxGptFlow.font = "14px 'SimSun'";
            ctxGptFlow.textAlign = "center";

            // Draw layers and connections
            for (let i = 0; i < gptLayers.length; i++) {
                const layer = gptLayers[i];
                ctxGptFlow.fillStyle = layer.active > 0.5 ? "#ffb74d" : "#90caf9"; // Orange when active, blue otherwise
                if (layer.type === "transformer") {
                    ctxGptFlow.fillRect(layer.x - 40, layer.y - 50, 80, 100);
                     // Inner details for transformer
                    ctxGptFlow.fillStyle = `rgba(255,255,255,${0.3 + layer.active * 0.3})`;
                    ctxGptFlow.fillRect(layer.x - 30, layer.y - 40, 60, 30); // Attention
                    ctxGptFlow.fillRect(layer.x - 30, layer.y + 10, 60, 30); // FFN
                } else {
                    ctxGptFlow.beginPath();
                    ctxGptFlow.arc(layer.x, layer.y, 40, 0, Math.PI * 2);
                    ctxGptFlow.fill();
                }
                ctxGptFlow.fillStyle = "#333";
                ctxGptFlow.fillText(layer.name, layer.x, layer.y + (layer.type === "transformer" ? 65 : 55));

                if (i < gptLayers.length - 1) {
                    ctxGptFlow.beginPath();
                    ctxGptFlow.moveTo(layer.x + (layer.type === "transformer" ? 40 : 0), layer.y);
                    ctxGptFlow.lineTo(gptLayers[i+1].x - (gptLayers[i+1].type === "transformer" ? 40 : 0), gptLayers[i+1].y);
                    ctxGptFlow.strokeStyle = "#78909c"; // Bluish grey
                    ctxGptFlow.lineWidth = 2;
                    ctxGptFlow.stroke();
                }
            }
            
            // Animate packets
            dataPackets.forEach(packet => {
                if (packet.currentLayer < gptLayers.length -1) {
                     const current = gptLayers[packet.currentLayer];
                     const next = gptLayers[packet.currentLayer+1];
                     packet.targetX = next.x;
                     packet.targetY = next.y - 15 + dataPackets.indexOf(packet)*15; // Stagger packets vertically
                } else { // Reached end or output layer
                    packet.targetX = canvasGptFlow.width - 50; // Move off screen
                }

                packet.x += (packet.targetX - packet.x) * 0.05;
                packet.y += (packet.targetY - packet.y) * 0.05;
                packet.progress += 0.05;

                ctxGptFlow.fillStyle = packet.color;
                ctxGptFlow.beginPath();
                ctxGptFlow.arc(packet.x, packet.y, 8, 0, Math.PI * 2);
                ctxGptFlow.fill();

                // Update layer activation and packet progression
                const distToTarget = Math.hypot(packet.targetX - packet.x, packet.targetY - packet.y);
                if (distToTarget < 10 && packet.currentLayer < gptLayers.length - 1) {
                    gptLayers[packet.currentLayer].active = 0; // Deactivate previous
                    packet.currentLayer++;
                    gptLayers[packet.currentLayer].active = 1; // Activate current
                    packet.progress = 0; // Reset progress for next segment
                     // For transformer, reset its internal "active" state quickly
                    if(gptLayers[packet.currentLayer-1].type === "transformer") gptLayers[packet.currentLayer-1].active = 0;
                }
                 // Keep last layer active if packet is there
                if(packet.currentLayer === gptLayers.length -1) gptLayers[packet.currentLayer].active = 1;

            });

            // Update overall progress and layer activity based on gptFlowProgress
            const activeLayerIndex = Math.floor(gptFlowProgress * gptLayers.length);
            gptLayers.forEach((layer, index) => {
                layer.active = (index === activeLayerIndex && gptFlowProgress < 1) ? Math.min(1, (gptFlowProgress * gptLayers.length) % 1 + 0.2) : (layer.active > 0 ? layer.active - 0.05 : 0) ;
                 if (index < activeLayerIndex) layer.active = 0.1; // Dimly active for passed layers
            });


            if (gptFlowProgress < 1.1) { // Extend a bit to let packets finish
                gptFlowProgress += 0.003; // Slower animation
                gptFlowAnimationId = requestAnimationFrame(drawGptFlow);
            } else {
                gptLayers.forEach(l => l.active = 0); // Deactivate all
                requestAnimationFrame(drawGptFlow); // Final draw
            }
        }
        document.getElementById('playGptFlow').addEventListener('click', () => {
            cancelAnimationFrame(gptFlowAnimationId);
            gptFlowProgress = 0;
            gptLayers.forEach(l => l.active = 0);
            initGptFlowPackets();
            drawGptFlow();
        });
        initGptFlowPackets();
        drawGptFlow(); // Initial draw

        // Animation 3: Capabilities Showcase (DOM manipulation)
        const capabilities = {
            gen_python_class: {
                title: "ç”ŸæˆPythonç±»",
                example: `æŒ‡ä»¤: "åˆ›å»ºä¸€ä¸ªPythonç±» 'Car'ï¼ŒåŒ…å«å±æ€§ make, model, yearï¼Œä»¥åŠä¸€ä¸ªæ–¹æ³• display_info æ‰“å°è½¦è¾†ä¿¡æ¯ã€‚"\n\nCodexè¾“å‡º (ç¤ºä¾‹):\nclass Car:\n    def __init__(self, make, model, year):\n        self.make = make\n        self.model = model\n        self.year = year\n\n    def display_info(self):\n        print(f"è½¦è¾†ä¿¡æ¯: {self.year} {self.make} {self.model}")`
            },
            explain_regex: {
                title: "è§£é‡Šæ­£åˆ™è¡¨è¾¾å¼",
                example: `æŒ‡ä»¤: "è§£é‡Šè¿™ä¸ªæ­£åˆ™è¡¨è¾¾å¼: ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"\n\nCodexè¾“å‡º (ç¤ºä¾‹):\nè¿™ä¸ªæ­£åˆ™è¡¨è¾¾å¼ç”¨äºåŒ¹é…ä¸€ä¸ªæ ‡å‡†çš„ç”µå­é‚®ä»¶åœ°å€æ ¼å¼ã€‚\n- ^: åŒ¹é…å­—ç¬¦ä¸²çš„å¼€å§‹ã€‚\n- [a-zA-Z0-9._%+-]+: åŒ¹é…ä¸€ä¸ªæˆ–å¤šä¸ªå­—æ¯ã€æ•°å­—ã€ç‚¹ã€ä¸‹åˆ’çº¿ã€ç™¾åˆ†å·ã€åŠ å·æˆ–å‡å· (ç”¨æˆ·åéƒ¨åˆ†)ã€‚\n- @: åŒ¹é…'@'ç¬¦å·ã€‚\n- [a-zA-Z0-9.-]+: åŒ¹é…ä¸€ä¸ªæˆ–å¤šä¸ªå­—æ¯ã€æ•°å­—ã€ç‚¹æˆ–å‡å· (åŸŸåéƒ¨åˆ†)ã€‚\n- \\.: åŒ¹é…'.'ç¬¦å·ã€‚\n- [a-zA-Z]{2,}: åŒ¹é…è‡³å°‘ä¸¤ä¸ªå­—æ¯ (é¡¶çº§åŸŸåï¼Œå¦‚ com, org)ã€‚\n- $: åŒ¹é…å­—ç¬¦ä¸²çš„ç»“æŸã€‚`
            },
            convert_sql_pandas: {
                title: "SQLæŸ¥è¯¢è½¬Pandasä»£ç ",
                example: `æŒ‡ä»¤: "å°†ä»¥ä¸‹SQLæŸ¥è¯¢è½¬æ¢ä¸ºç­‰æ•ˆçš„Pandas Pythonä»£ç : SELECT product_name, SUM(quantity) AS total_quantity FROM sales WHERE category = 'Electronics' GROUP BY product_name ORDER BY total_quantity DESC;"\n\nCodexè¾“å‡º (ç¤ºä¾‹):\n# å‡è®¾dfæ˜¯åŒ…å«é”€å”®æ•°æ®çš„Pandas DataFrame\n# df çš„åˆ—åº”åŒ…æ‹¬: 'product_name', 'quantity', 'category'\n\nelectronics_sales = df[df['category'] == 'Electronics']\ntotal_quantity_by_product = electronics_sales.groupby('product_name')['quantity'].sum().reset_index()\ntotal_quantity_by_product = total_quantity_by_product.rename(columns={'quantity': 'total_quantity'})\nsorted_products = total_quantity_by_product.sort_values(by='total_quantity', ascending=False)`
            }
        };
        const capabilityDisplay = document.getElementById('capabilityDisplay');
        function showCapability(key) {
            capabilityDisplay.innerHTML = `<strong>${capabilities[key].title}</strong>\n\n${capabilities[key].example}`;
            document.querySelectorAll('.tabs button').forEach(btn => {
                btn.style.backgroundColor = '#3949ab'; // Reset color
                btn.style.fontWeight = 'normal';
            });
            event.currentTarget.style.backgroundColor = '#283593'; // Active tab darker
            event.currentTarget.style.fontWeight = 'bold';
        }
        // Initial display for capabilities
        showCapability('gen_python_class'); // Show first tab by default
        document.querySelector('.tabs button').style.backgroundColor = '#283593'; // Highlight first tab
        document.querySelector('.tabs button').style.fontWeight = 'bold';


        // Animation 4: The "Black Box" & Probabilistic Output
        const canvasBlackBox = document.getElementById('blackBoxCanvas');
        const ctxBlackBox = canvasBlackBox.getContext('2d');
        let blackBoxAnimationId;
        let bbProgress = 0; // Overall animation progress
        let paths = [];
        const numPaths = 5;

        function initBlackBoxPaths() {
            paths = [];
            for (let i = 0; i < numPaths; i++) {
                paths.push({
                    prob: Math.random() * 0.6 + 0.1, // Random probability
                    angle: (Math.random() - 0.5) * Math.PI / 3, // Spread angles
                    selected: false,
                    brightness: 0
                });
            }
            // Ensure one path is "selected" (highest probability for demo)
            paths.sort((a,b) => b.prob - a.prob);
            paths[0].selected = true;
            paths[0].prob = Math.random() * 0.3 + 0.7; // Make selected one higher
        }


        function drawBlackBox() {
            ctxBlackBox.clearRect(0, 0, canvasBlackBox.width, canvasBlackBox.height);
            const boxCenterX = canvasBlackBox.width / 2;
            const boxCenterY = canvasBlackBox.height / 2;
            const boxWidth = 150;
            const boxHeight = 100;

            // Input Arrow
            ctxBlackBox.fillStyle = "#3949ab";
            ctxBlackBox.font = "16px 'SimSun'";
            ctxBlackBox.textAlign = "center";
            ctxBlackBox.fillText("è¾“å…¥æŒ‡ä»¤", boxCenterX - 150, boxCenterY - 20);
            ctxBlackBox.beginPath();
            ctxBlackBox.moveTo(boxCenterX - 200, boxCenterY);
            ctxBlackBox.lineTo(boxCenterX - boxWidth/2 - 10, boxCenterY);
            ctxBlackBox.lineTo(boxCenterX - boxWidth/2 - 20, boxCenterY - 5);
            ctxBlackBox.moveTo(boxCenterX - boxWidth/2 - 10, boxCenterY);
            ctxBlackBox.lineTo(boxCenterX - boxWidth/2 - 20, boxCenterY + 5);
            ctxBlackBox.strokeStyle = "#3949ab";
            ctxBlackBox.lineWidth = 3;
            ctxBlackBox.stroke();

            // Black Box
            ctxBlackBox.fillStyle = "#37474F"; // Dark grey blue
            ctxBlackBox.fillRect(boxCenterX - boxWidth/2, boxCenterY - boxHeight/2, boxWidth, boxHeight);
            ctxBlackBox.fillStyle = "white";
            ctxBlackBox.font = "bold 20px 'SimSun'";
            ctxBlackBox.fillText("AI æ¨¡å‹", boxCenterX, boxCenterY - 10);
            ctxBlackBox.font = "bold 30px Arial";
            ctxBlackBox.fillText("?", boxCenterX, boxCenterY + 20);

            // Probabilistic Output Paths
            if (bbProgress > 0.3) {
                const pathStartRatio = (bbProgress - 0.3) / 0.7;
                paths.forEach(path => {
                    const pathLength = 150 * Math.min(1, pathStartRatio * 2);
                    const endX = boxCenterX + boxWidth/2 + pathLength * Math.cos(path.angle);
                    const endY = boxCenterY + pathLength * Math.sin(path.angle);
                    
                    ctxBlackBox.beginPath();
                    ctxBlackBox.moveTo(boxCenterX + boxWidth/2, boxCenterY);
                    ctxBlackBox.lineTo(endX, endY);

                    if (path.selected && pathStartRatio > 0.5) {
                        path.brightness = Math.min(1, path.brightness + 0.05);
                        ctxBlackBox.strokeStyle = `rgba(76, 175, 80, ${path.brightness})`; // Green for selected
                        ctxBlackBox.lineWidth = 4;
                         if (pathStartRatio > 0.8) { // Show "Output Code" text
                            ctxBlackBox.fillStyle = "#2E7D32";
                            ctxBlackBox.font = "16px 'SimSun'";
                            ctxBlackBox.fillText("è¾“å‡ºä»£ç ", boxCenterX + 150, boxCenterY + 20);
                        }
                    } else {
                        path.brightness = Math.max(0.1, path.brightness - 0.02);
                        ctxBlackBox.strokeStyle = `rgba(120, 144, 156, ${0.2 + path.prob * 0.5 * pathStartRatio + path.brightness * 0.3})`; // Grey for others
                        ctxBlackBox.lineWidth = 2;
                    }
                    ctxBlackBox.stroke();
                    
                    // Probability text
                    if (pathStartRatio > 0.2 && pathLength > 30) {
                         ctxBlackBox.fillStyle = path.selected ? "#2E7D32" : "#78909c";
                         ctxBlackBox.font = "12px Arial";
                         ctxBlackBox.fillText(`P=${path.prob.toFixed(2)}`, 
                                             boxCenterX + boxWidth/2 + (pathLength/2)*Math.cos(path.angle) + 10*Math.sin(path.angle), 
                                             boxCenterY + (pathLength/2)*Math.sin(path.angle) - 10*Math.cos(path.angle));
                    }
                });
            }
            
            if (bbProgress < 1) {
                bbProgress += 0.01;
                blackBoxAnimationId = requestAnimationFrame(drawBlackBox);
            } else {
                 // Ensure selected path stays bright
                paths.find(p=>p.selected).brightness = 1;
                requestAnimationFrame(drawBlackBox); // final draw
            }
        }

        document.getElementById('playBlackBox').addEventListener('click', () => {
            cancelAnimationFrame(blackBoxAnimationId);
            bbProgress = 0;
            initBlackBoxPaths();
            drawBlackBox();
        });
        initBlackBoxPaths();
        drawBlackBox();


        // Animation 5: Developer-Codex Iterative Workflow
        const canvasWorkflow = document.getElementById('workflowCanvas');
        const ctxWorkflow = canvasWorkflow.getContext('2d');
        let workflowAnimationId;
        let wfState = 0; // 0: Dev Prompts, 1: Codex Generates, 2: Dev Reviews, 3: Dev Refines, 4: Codex Generates v2
        let wfProgress = 0; // Progress within a state (0 to 1)
        const wfElements = {
            dev: { x: 100, y: 125, text: "å¼€å‘è€…", icon: "ğŸ§‘â€ğŸ’»" },
            codex: { x: 550, y: 125, text: "Codex AI", icon: "ğŸ¤–" },
            promptBubble: { x: 250, y: 80, text: "åˆå§‹æŒ‡ä»¤", opacity: 0 },
            codeBubble1: { x: 400, y: 170, text: "ä»£ç  v1", opacity: 0 },
            reviewAction: { x: 100, y: 170, text: "å®¡æŸ¥/æµ‹è¯•", opacity: 0 },
            refineBubble: { x: 250, y: 80, text: "ä¼˜åŒ–æŒ‡ä»¤", opacity: 0 },
            codeBubble2: { x: 400, y: 170, text: "ä»£ç  v2", opacity: 0 }
        };

        function drawWorkflow() {
            ctxWorkflow.clearRect(0, 0, canvasWorkflow.width, canvasWorkflow.height);
            ctxWorkflow.font = "16px 'SimSun'";
            ctxWorkflow.textAlign = "center";

            // Draw Dev and Codex actors
            [wfElements.dev, wfElements.codex].forEach(actor => {
                ctxWorkflow.font = "40px Arial"; // Icon size
                ctxWorkflow.fillText(actor.icon, actor.x, actor.y);
                ctxWorkflow.font = "16px 'SimSun'";
                ctxWorkflow.fillStyle = "#333";
                ctxWorkflow.fillText(actor.text, actor.x, actor.y + 30);
            });

            // Draw bubbles and actions based on state and progress
            function drawBubble(bubble, fromActor, toActor, isResponse=false) {
                if (bubble.opacity > 0) {
                    ctxWorkflow.globalAlpha = bubble.opacity;
                    ctxWorkflow.fillStyle = isResponse ? "#E8F5E9" : "#E3F2FD"; // Light green for response, light blue for prompt
                    ctxWorkflow.strokeStyle = isResponse ? "#A5D6A7" : "#90CAF9";
                    const metrics = ctxWorkflow.measureText(bubble.text);
                    const bubbleWidth = metrics.width + 30;
                    const bubbleHeight = 40;
                    ctxWorkflow.beginPath();
                    // Simple rounded rect for bubble
                    ctxWorkflow.roundRect(bubble.x - bubbleWidth/2, bubble.y - bubbleHeight/2, bubbleWidth, bubbleHeight, [10]);
                    ctxWorkflow.fill();
                    ctxWorkflow.stroke();
                    ctxWorkflow.fillStyle = "#333";
                    ctxWorkflow.fillText(bubble.text, bubble.x, bubble.y + 5);
                    
                    // Arrow
                    ctxWorkflow.beginPath();
                    const startX = fromActor.x + (isResponse ? -20 : 20) * (fromActor.x < bubble.x ? 1: -1) ; // Adjust based on direction
                    const startY = fromActor.y - (isResponse ? 0 : 20) ;
                    const endX = bubble.x + (isResponse ? 20 : -20) * (bubble.x < fromActor.x ? 1: -1) ;
                    const endY = bubble.y;
                    ctxWorkflow.moveTo(startX, startY);
                    ctxWorkflow.lineTo(endX, endY);
                    // Arrowhead
                    const angle = Math.atan2(endY - startY, endX - startX);
                    ctxWorkflow.lineTo(endX - 10 * Math.cos(angle - Math.PI / 6), endY - 10 * Math.sin(angle - Math.PI / 6));
                    ctxWorkflow.moveTo(endX, endY);
                    ctxWorkflow.lineTo(endX - 10 * Math.cos(angle + Math.PI / 6), endY - 10 * Math.sin(angle + Math.PI / 6));
                    ctxWorkflow.strokeStyle = "#546E7A";
                    ctxWorkflow.lineWidth = 2;
                    ctxWorkflow.stroke();
                    ctxWorkflow.globalAlpha = 1;
                }
            }
            
            function drawActionText(action) {
                 if (action.opacity > 0) {
                    ctxWorkflow.globalAlpha = action.opacity;
                    ctxWorkflow.fillStyle = "#FFB74D"; // Orange for action
                    ctxWorkflow.fillText(action.text, action.x, action.y + 5);
                    ctxWorkflow.globalAlpha = 1;
                 }
            }

            // State machine for animation
            wfProgress += 0.02;
            if (wfProgress > 1) {
                wfProgress = 0;
                wfState = (wfState + 1) % 5; // Cycle through 5 states
                 // Reset opacities for next state
                Object.values(wfElements).forEach(el => { if(el.opacity !== undefined) el.opacity = 0; });
            }

            switch(wfState) {
                case 0: // Dev prompts
                    wfElements.promptBubble.opacity = wfProgress;
                    drawBubble(wfElements.promptBubble, wfElements.dev, wfElements.codex);
                    break;
                case 1: // Codex generates code v1
                    wfElements.promptBubble.opacity = 1; // Keep visible
                    drawBubble(wfElements.promptBubble, wfElements.dev, wfElements.codex);
                    wfElements.codeBubble1.opacity = wfProgress;
                    drawBubble(wfElements.codeBubble1, wfElements.codex, wfElements.dev, true);
                    break;
                case 2: // Dev reviews
                    wfElements.promptBubble.opacity = 1; 
                    drawBubble(wfElements.promptBubble, wfElements.dev, wfElements.codex);
                    wfElements.codeBubble1.opacity = 1;
                    drawBubble(wfElements.codeBubble1, wfElements.codex, wfElements.dev, true);
                    wfElements.reviewAction.opacity = wfProgress;
                    drawActionText(wfElements.reviewAction);
                    break;
                case 3: // Dev refines prompt
                    wfElements.reviewAction.opacity = 1;
                    drawActionText(wfElements.reviewAction);
                    wfElements.refineBubble.opacity = wfProgress;
                    drawBubble(wfElements.refineBubble, wfElements.dev, wfElements.codex);
                    break;
                case 4: // Codex generates code v2
                    wfElements.refineBubble.opacity = 1;
                    drawBubble(wfElements.refineBubble, wfElements.dev, wfElements.codex);
                    wfElements.codeBubble2.opacity = wfProgress;
                    drawBubble(wfElements.codeBubble2, wfElements.codex, wfElements.dev, true);
                    break;
            }
            
            workflowAnimationId = requestAnimationFrame(drawWorkflow);
        }
        
        document.getElementById('playWorkflow').addEventListener('click', () => {
            cancelAnimationFrame(workflowAnimationId);
            wfState = 0;
            wfProgress = 0;
            Object.values(wfElements).forEach(el => { if(el.opacity !== undefined) el.opacity = 0; });
            drawWorkflow();
        });
        drawWorkflow(); // Initial draw

        // Utility for roundRect if not natively supported (for older browsers, though modern ones are fine)
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.beginPath();
                this.moveTo(x+r, y);
                this.arcTo(x+w, y,   x+w, y+h, r);
                this.arcTo(x+w, y+h, x,   y+h, r);
                this.arcTo(x,   y+h, x,   y,   r);
                this.arcTo(x,   y,   x+w, y,   r);
                this.closePath();
                return this;
            }
        }

    </script>
</body>
</html>

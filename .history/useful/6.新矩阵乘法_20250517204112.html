<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RXTX算法深度解析与动画演示</title>
    <script defer src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .content-section { margin-bottom: 3rem; padding: 1.5rem; background-color: #f9fafb; border-radius: 0.5rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
        .animation-container { margin-top: 1rem; margin-bottom: 1rem; border: 1px solid #e5e7eb; border-radius: 0.5rem; overflow: hidden; background-color: #f8f9fa; /* Light background for canvas containers */ }
        canvas { display: block; margin: auto; /* background-color: #fff; Let p5 sketch handle bg */ }
        .controls { text-align: center; margin-top: 0.5rem; margin-bottom: 1rem; }
        .controls button { background-color: #3b82f6; color: white; padding: 0.5rem 1rem; border-radius: 0.375rem; border: none; cursor: pointer; margin: 0 0.25rem; transition: background-color 0.3s; }
        .controls button:hover { background-color: #2563eb; }
        h2 { font-size: 1.75rem; font-weight: 600; margin-bottom: 1rem; color: #1f2937; }
        h3 { font-size: 1.25rem; font-weight: 500; margin-top: 1.5rem; margin-bottom: 0.75rem; color: #374151; }
        p, li { line-height: 1.6; color: #4b5563; text-align: justify; }
        ul { list-style-type: disc; margin-left: 1.5rem; }
        .formula { font-family: monospace; background-color: #e5e7eb; padding: 0.25rem 0.5rem; border-radius: 0.25rem; display: inline-block; }
        .chart-container { margin: 1rem auto; /* Centering chart containers */ }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 p-4 md:p-8">
    <div class="max-w-4xl mx-auto bg-white shadow-xl rounded-lg p-6 md:p-10">

        <header class="text-center mb-12">
            <h1 class="text-4xl font-bold text-blue-600">RXTX算法：矩阵与其转置乘积计算的革新</h1>
            <p class="text-lg text-gray-600 mt-2">一篇关于 "XX<sup>T</sup> Can Be Faster" 论文的物理逻辑视角深度解读</p>
        </header>

        <section class="content-section">
            <h2>1. 引言：矩阵乘法的重要性与RXTX的突破</h2>
            <p>矩阵乘法是科学计算和数据分析领域的核心运算之一。特别地，计算一个矩阵X与其自身的转置X<sup>T</sup>的乘积（即XX<sup>T</sup>）在统计学（如计算协方差矩阵）、机器学习（如主成分分析PCA、线性回归的法方程 X<sup>T</sup>Xb = X<sup>T</sup>y）、信号处理和无线通信等众多领域都有着广泛应用。这类计算的效率直接影响到复杂系统的整体性能。</p>
            <p>传统的矩阵乘法算法虽然直观，但在计算大规模矩阵时，其计算复杂度较高。Strassen算法及其变种通过分治策略减少了乘法次数，从而在理论上降低了复杂度。然而，针对XX<sup>T</sup>这类具有特定结构的矩阵乘法，仍有进一步优化的空间。</p>
            <p>论文《XX<sup>T</sup> Can Be Faster》提出了一种名为RXTX的新算法，专门用于计算XX<sup>T</sup>。该算法通过结合机器学习的搜索方法和组合优化技术被发现，其核心优势在于：与当前最优算法（State-of-the-Art, SotA）相比，RXTX在计算XX<sup>T</sup>时能够减少约5%的乘法和加法运算次数，并且即使对于小规模矩阵也能提供加速效果。这对于追求极致计算效率的应用场景具有重要意义。</p>
        </section>

        <section class="content-section">
            <h2>2. 理解XX<sup>T</sup>：概念与应用</h2>
            <p>一个矩阵X乘以其转置X<sup>T</sup>，得到的结果是一个对称矩阵。如果X的每一行代表一个数据点（或样本），每一列代表一个特征，那么XX<sup>T</sup>的对角线元素表示每个数据点内各特征平方和，而非对角线元素则表示不同数据点之间的内积，这与样本间的相似性或相关性有关。如果X的每一列代表一个数据点，则X<sup>T</sup>X是更常见的形式，用于计算特征间的协方差矩阵或格拉姆矩阵。</p>
            <p><strong>XX<sup>T</sup>的物理逻辑意义：</strong></p>
            <ul>
                <li><strong>能量/方差度量：</strong> 在许多物理或统计模型中，向量的内积（或其自身的内积）可以解释为能量或方差。XX<sup>T</sup>的对角线元素 (XX<sup>T</sup>)<sub>ii</sub> 是原矩阵X的第i行向量与其自身的内积，可以视为第i个样本（或信号）的能量或其分量的平方和。</li>
                <li><strong>相关性/投影度量：</strong> 非对角线元素 (XX<sup>T</sup>)<sub>ij</sub> 是X的第i行与第j行的内积。这可以衡量两个样本向量之间的相似度或相关性。如果向量经过中心化处理，则这与协方差直接相关。</li>
                <li><strong>变换与对称性：</strong> XX<sup>T</sup>总是半正定的，如果X是实数矩阵。这种结构在许多优化问题和物理系统中自然出现，例如在弹性力学中描述应变能，或在量子力学中描述密度矩阵的某些性质。</li>
            </ul>
            <div class="animation-container">
                <h3 class="text-center">动画1：XX<sup>T</sup> 概念演示</h3>
                <div id="canvasContainer1" class="flex justify-center items-center p-4 bg-gray-50 rounded-md min-h-[280px]"></div>
                <div class="controls">
                    <button id="playBtn1">播放/重置</button>
                </div>
            </div>
            <p>下面的动画将直观展示一个简单矩阵X如何与其转置X<sup>T</sup>相乘得到XX<sup>T</sup>，并突出显示结果矩阵中元素的含义。</p>
        </section>

        <section class="content-section">
            <h2>3. RXTX算法核心：递归分块与优化</h2>
            <p>RXTX算法的核心思想是基于递归的分块矩阵乘法。与先前主要依赖Strassen类算法（通常基于2x2分块）进行递归的SotA方法不同，RXTX采用了一种新颖的4x4分块策略。</p>
            <p>具体来说，当计算一个n x n矩阵X的XX<sup>T</sup>时：</p>
            <ul>
                <li><strong>RXTX算法：</strong> 将矩阵X视为4x4的块矩阵（每个块的大小为n/4 x n/4）。通过精心设计的计算步骤，它将原始问题分解为8个对n/4规模子矩阵的递归XX<sup>T</sup>计算，以及26个n/4规模的通用矩阵乘法。其递归关系式为：<span class="formula">R(n) = 8R(n/4) + 26M(n/4)</span>，其中R(n)是RXTX算法计算n x n矩阵XX<sup>T</sup>的乘法次数，M(n)是Strassen类算法计算通用矩阵乘积的乘法次数。</li>
                <li><strong>先前SotA算法（基于Strassen）：</strong> 通常将矩阵X视为2x2的块矩阵。它将问题分解为4个对n/2规模子矩阵的递归XX<sup>T</sup>计算和2个n/2规模的通用矩阵乘法。其递归关系式为：<span class="formula">S(n) = 4S(n/2) + 2M(n/2)</span>。</li>
            </ul>
            <p>这种4x4分块结构和特定的26个通用乘积组合是RXTX算法能够减少总运算量的关键。这些组合并非凭空而来，而是通过复杂的机器学习搜索和组合优化技术发现的，旨在最大限度地重用中间计算结果，减少冗余运算。</p>
            <div class="animation-container">
                <h3 class="text-center">动画2：RXTX 与 SotA 递归结构对比</h3>
                <div id="canvasContainer2" class="flex justify-center items-center p-4 bg-gray-50 rounded-md min-h-[300px]"></div>
                <div class="controls">
                    <button id="playBtn2">演示分解</button>
                </div>
            </div>
            <p>以下动画将对比展示RXTX算法的4x4分块与传统SotA算法的2x2分块在递归分解上的概念差异。</p>
        </section>

        <section class="content-section">
            <h2>4. 性能分析：乘法运算次数的显著减少</h2>
            <p>算法效率的一个关键衡量指标是所需乘法运算的次数，因为乘法通常比加法更耗时。论文通过理论分析证明了RXTX在乘法次数上的优势。</p>
            <p>对于一个n x n的矩阵X，使用Strassen算法进行通用矩阵乘法（M(n)）的复杂度约为 O(n<sup>log<sub>2</sub>7</sup>)，其中log<sub>2</sub>7 ≈ 2.807。</p>
            <ul>
                <li><strong>RXTX算法的乘法次数：</strong> <span class="formula">R(n) ≈ (26/41) * M(n) + (15/41) * n<sup>1.5</sup></span>。渐进地，R(n) ≈ (26/41) * n<sup>log<sub>2</sub>7</sup>。这里的系数 26/41 ≈ 0.6341。</li>
                <li><strong>SotA算法的乘法次数：</strong> <span class="formula">S(n) ≈ (2/3) * M(n) + (1/3) * n<sup>2</sup></span>。渐进地，S(n) ≈ (2/3) * n<sup>log<sub>2</sub>7</sup>。这里的系数 2/3 ≈ 0.6667。</li>
            </ul>
            <p>比较这两个渐进系数，RXTX的系数 (26/41) 小于 SotA的系数 (2/3)。具体来说，(26/41) / (2/3) ≈ 0.6341 / 0.6667 ≈ 0.951。这意味着RXTX算法在渐进意义下，其乘法次数比SotA算法减少了大约 1 - 0.951 = 4.9%，接近论文中提到的5%。</p>
            <div class="animation-container">
                <h3 class="text-center">动画3：RXTX 与 SotA 乘法次数比率 R(n)/S(n)</h3>
                <div class="chart-container" style="width:95%; max-width:500px; height:300px; margin: 1rem auto;">
                    <canvas id="chart3"></canvas>
                </div>
                <div class="controls">
                    <button id="playBtn3">绘制图表</button>
                </div>
            </div>
            <p>下面的图表动画将展示随着矩阵规模n的增加（以4的幂次表示），RXTX算法与SotA算法乘法次数的比率R(n)/S(n)的变化趋势，直观显示其5%的性能提升。</p>
        </section>

        <section class="content-section">
            <h2>5. 性能分析：总操作数与实际运行时间</h2>
            <p>除了乘法次数，算法的总操作数（包括加法和乘法）以及在真实硬件上的运行时间也是衡量其性能的重要标准。论文进一步分析了RXTX算法的总操作数，并进行了实验验证。</p>
            <p>通过优化加法步骤（论文中Algorithm 2和3详细描述了优化的加法方案，将原始139次加法减少到100次），RXTX在总操作数上也展现出优势，尤其是在矩阵规模n ≥ 256时，其总操作数开始优于递归Strassen方法。</p>
            <p>更重要的是实际运行时间的对比。论文在特定硬件环境下（10th Gen Intel Core i7-10510U处理器，单线程），对6144x6144的随机密集矩阵进行了1000次测试。实验结果（如图Fig. 5所示）表明：</p>
            <ul>
                <li>RXTX算法的平均运行时间为2.524秒。</li>
                <li>默认的BLAS-3库函数（针对XX<sup>T</sup>优化）的平均运行时间为2.778秒。</li>
            </ul>
            <p>这意味着RXTX算法在实际运行中比高度优化的BLAS库函数快了约9%。在99%的测试中，RXTX都表现出更快的速度。这证明了RXTX算法不仅在理论上具有优势，在实践中也能带来显著的性能提升。</p>
            <div class="animation-container">
                <h3 class="text-center">动画4：RXTX 与默认BLAS 运行时间对比 (模拟)</h3>
                <div class="chart-container" style="width:95%; max-width:500px; height:300px; margin: 1rem auto;">
                    <canvas id="chart4"></canvas>
                </div>
                <div class="controls">
                    <button id="playBtn4">显示数据</button>
                </div>
            </div>
            <p>以下动画将模拟论文中Figure 5的直方图，展示RXTX算法与默认BLAS库在计算6144x6144矩阵XX<sup>T</sup>时的运行时间分布对比。</p>
        </section>

        <section class="content-section">
            <h2>6. RXTX算法的发现之旅：AI与优化的结合</h2>
            <p>RXTX算法并非通过传统的人工推导发现，而是结合了先进的机器学习（特别是强化学习RL）和组合优化技术。这种创新的发现方法本身也是论文的一大亮点。</p>
            <p>其核心方法论可以概括为一个“RL引导的大邻域搜索 (Large Neighborhood Search, LNS)”与一个两阶段混合整数线性规划 (Mixed-Integer Linear Programming, MILP) 流水线的结合：</p>
            <ol class="list-decimal ml-6">
                <li class="mb-2"><strong>RL代理提议：</strong> 强化学习代理首先提出一组可能冗余的秩-1双线性乘积候选项。这些候选项构成了计算XX<sup>T</sup>中各个目标表达式的基础。</li>
                <li class="mb-2"><strong>MILP-A枚举关系：</strong> 第一个MILP模型（MILP-A）在这些候选项和XX<sup>T</sup>的目标表达式之间，穷举搜索并生成数以万计的线性关系。</li>
                <li class="mb-2"><strong>MILP-B选择子集：</strong> 第二个MILP模型（MILP-B）从这些关系中选择一个最小的乘积子集，确保这些选出的乘积及其线性组合能够覆盖XX<sup>T</sup>的所有目标表达式，从而构成一个完整的计算方案。</li>
            </ol>
            <p>这个过程在LNS框架下迭代进行，不断优化和发现更高效的计算方案。这种方法可以看作是对AlphaTensor（一个用RL发现矩阵乘法算法的著名工作）思想的简化和特定化：它不是在巨大的张量空间中直接搜索，而是先由RL采样候选张量，再由MILP求解器找到这些候选张量的最优线性组合。这种人机协作的模式为发现复杂算法提供了新的途径。</p>
            <div class="animation-container">
                <h3 class="text-center">动画5：RXTX算法发现流程示意</h3>
                <div id="canvasContainer5" class="flex justify-center items-center p-4 bg-gray-50 rounded-md min-h-[380px]"></div>
                <div class="controls">
                    <button id="playBtn5">开始/重置</button>
                    <button id="nextStepBtn5">下一步</button>
                </div>
            </div>
            <p>动画演示RXTX算法的发现流程：RL代理提议→MILP-A枚举→MILP-B选择→迭代优化</p>
        </section>
        
        <section class="content-section">
            <h2>7. 结论与展望</h2>
            <p>RXTX算法的提出，为计算矩阵与其转置的乘积XX<sup>T</sup>提供了一种新的、更高效的方法。通过新颖的4x4分块递归策略和由AI辅助发现的优化计算路径，RXTX在理论上减少了约5%的乘法运算，并在实际测试中展现出高达9%的运行时间加速，即使对于小规模矩阵也有效。</p>
            <p><strong>物理逻辑启示：</strong></p>
            <ul>
                <li><strong>结构特异性优化：</strong> RXTX的成功强调了针对特定问题结构（如XX<sup>T</sup>的对称性和计算模式）进行算法优化的重要性，而不是仅仅依赖通用算法。物理系统中，对称性和守恒律往往导致简化的数学描述；类似地，在计算中利用结构特性也能带来效率提升。</li>
                <li><strong>计算路径的探索：</strong> 传统算法设计多依赖人类直觉和数学推导。RXTX的发现过程表明，复杂的计算路径可以通过AI搜索和组合优化技术被有效地探索和发现。这类似于在复杂系统中寻找最优路径或最低能量状态，计算本身可以被视为一种需要在高维空间中优化的“物理过程”。</li>
                <li><strong>分治与层级：</strong> 递归分块的思想是分治策略的体现，这在物理学中也常见，如将复杂系统分解为子系统研究，或在不同尺度上分析现象。RXTX的4x4分块相较于2x2分块，可以看作是在一个更粗粒度的层级上进行分解，但通过更精巧的组合方式获得了整体更优的性能。</li>
            </ul>
            <p>这项工作不仅为特定的矩阵运算提供了加速，更展示了AI技术在基础算法发现领域的巨大潜力。未来，类似的方法有望应用于更多结构化矩阵运算或其他计算密集型问题，推动科学计算和数据处理能力的进一步发展。同时，对RXTX算法在不同硬件平台上的适应性和优化，以及将其推广到更一般情况（如复数矩阵或稀疏矩阵）的研究，也将是值得探索的方向。</p>
        </section>

        <footer class="text-center mt-12 py-6 border-t border-gray-300">
            <p class="text-sm text-gray-500">RXTX算法解读与动画演示 &copy; 2025</p>
            <p class="text-xs text-gray-400 mt-1">基于论文 "XX<sup>T</sup> Can Be Faster" (arXiv:2505.09814v1)</p>
        </footer>

    </div>

<script>
// Animation 1: XX^T Concept
const sketch1 = (p) => {
    let matrixX, matrixXT, matrixXXT;
    let animationSpeed = 60; // frames
    let currentFrame = 0;
    let cols = 2, rows = 3; // X is rows x cols (e.g., 3x2)
    let cellSize = 40;
    let margin = 20;
    let stage = 0; // 0: initial, 1: show X, 2: show XT, 3: show multiply, 4: show result

    p.setup = () => {
        const canvas = p.createCanvas(400, 250 + (rows > 2 ? (rows-2)*cellSize : 0) ); // Adjust height for matrix size
        canvas.parent('canvasContainer1');
        p.textAlign(p.CENTER, p.CENTER);
        p.textSize(14);
        resetAnimation1();
        document.getElementById('playBtn1').onclick = resetAnimation1;
    };

    function resetAnimation1() {
        stage = 0;
        currentFrame = 0;
        matrixX = Array(rows).fill(0).map(() => Array(cols).fill(0).map(() => p.floor(p.random(1, 10))));
        // XT is cols x rows
        matrixXT = Array(cols).fill(0).map((_, c) => Array(rows).fill(0).map((_, r) => matrixX[r][c]));
        // XXT is rows x rows
        matrixXXT = Array(rows).fill(0).map((_, i) => Array(rows).fill(0).map((_, j) => {
            let sum = 0;
            for (let k = 0; k < cols; k++) { // k iterates over columns of X (and rows of XT)
                sum += matrixX[i][k] * matrixXT[k][j]; // matrixXT[k][j] is X[j][k]
            }
            return sum;
        }));
        if (!p.isLooping()) p.loop();
    }

    p.draw = () => {
        p.background(245, 248, 252); // Light background
        currentFrame++;

        // Animation state transitions
        if (stage === 0 && currentFrame > animationSpeed / 3) { stage = 1; currentFrame = 0; }
        else if (stage === 1 && currentFrame > animationSpeed) { stage = 2; currentFrame = 0; }
        else if (stage === 2 && currentFrame > animationSpeed) { stage = 3; currentFrame = 0; }
        else if (stage === 3 && currentFrame > animationSpeed * 1.5) { stage = 4; currentFrame = 0; }
        else if (stage === 4 && currentFrame > animationSpeed * 2) { p.noLoop(); }

        let baseX = 30, baseY = 60; // Adjusted baseY for better centering
        if (stage >= 1) drawMatrix(matrixX, baseX, baseY, "X");

        // matrixXT has `cols` rows and `rows` columns
        let xOffsetXT = baseX + cols * cellSize + 40;
        // Adjust Y position of XT to align centers if dimensions differ significantly
        let yOffsetXT = baseY + (rows * cellSize - cols * cellSize) / 2;
        if (stage >= 2) drawMatrix(matrixXT, xOffsetXT, yOffsetXT, "Xᵀ");
        
        if (stage >= 3) {
            p.textSize(20);
            p.fill(0);
            // Labels for X and XT already drawn by drawMatrix
            p.text("=", xOffsetXT + matrixXT[0].length * cellSize + 25, baseY + rows*cellSize/2);
            p.textSize(14);
        }
        
        // matrixXXT has `rows` rows and `rows` columns
        let xOffsetXXT = xOffsetXT + matrixXT[0].length * cellSize + 50;
        if (stage === 3) { 
            p.fill(200);
            p.stroke(150);
            for(let i=0; i<rows; i++) {
                for(let j=0; j<rows; j++) {
                    p.rect(xOffsetXXT + j*cellSize, baseY + i*cellSize, cellSize, cellSize, 4); // Rounded rects
                    p.fill(100);
                    p.noStroke();
                    p.text("?", xOffsetXXT + j*cellSize + cellSize/2, baseY + i*cellSize + cellSize/2);
                    p.fill(200);
                    p.stroke(150);
                }
            }
            p.fill(0);
            p.noStroke();
            p.text("XXᵀ", xOffsetXXT + rows*cellSize/2, baseY - margin);
        }

        if (stage >= 4) {
            drawMatrix(matrixXXT, xOffsetXXT, baseY, "XXᵀ", true);
        }
    };

    function drawMatrix(matrixData, x, y, label, highlight = false) {
        p.push();
        p.translate(x, y);
        p.fill(0);
        p.noStroke();
        p.text(label, matrixData[0].length * cellSize / 2, -margin);
        
        for (let i = 0; i < matrixData.length; i++) {
            for (let j = 0; j < matrixData[0].length; j++) {
                if (highlight && i === j) p.fill(255, 224, 130, 200); // Softer highlight for diagonal
                else if (highlight) p.fill(210, 220, 255, 200); // Softer for other elements of XXT
                else p.fill(230, 235, 240); 
                
                p.stroke(180);
                p.rect(j * cellSize, i * cellSize, cellSize, cellSize, 4); // Rounded rects
                
                p.fill(50); // Darker text for numbers
                p.noStroke();
                p.text(matrixData[i][j], j * cellSize + cellSize / 2, i * cellSize + cellSize / 2);
            }
        }
        p.pop();
    }
};
new p5(sketch1);

// Animation 2: RXTX vs SotA Recursive Structure
const sketch2 = (p) => {
    let stage = 0; // 0: initial, 1: SotA 2x2, 2: RXTX 4x4
    let matrixSize = 160; // Main matrix size
    let padding = 30; // Padding around matrices

    p.setup = () => {
        const canvas = p.createCanvas(2 * matrixSize + 3 * padding, matrixSize + 2*padding + 40); // Adjusted canvas size
        canvas.parent('canvasContainer2');
        p.textAlign(p.CENTER, p.CENTER);
        p.textSize(12);
        document.getElementById('playBtn2').onclick = () => {
            stage = (stage + 1) % 3;
            if (stage === 0) {
                p.noLoop();
            } else {
                p.loop(); // Loop if stages have internal animation (not currently, but good practice)
            }
            p.redraw(); // Ensure it redraws for the new stage
        };
        p.noLoop(); // Start paused
        p.redraw(); // Draw initial state
    };

    p.draw = () => {
        p.background(245, 248, 252);
        
        let startX_SotA = padding;
        let startX_RXTX = matrixSize + 2 * padding;
        let startY = padding + 20; // Y start for matrix drawing, below title

        p.fill(0);
        p.noStroke();
        p.text("SotA (2x2分块)", startX_SotA + matrixSize/2, padding); // Title Y
        p.text("RXTX (4x4分块)", startX_RXTX + matrixSize/2, padding); // Title Y

        drawBlockMatrix(startX_SotA, startY, matrixSize, 2, stage >= 1, "S(n) = 4S(n/2) + 2M(n/2)");
        drawBlockMatrix(startX_RXTX, startY, matrixSize, 4, stage >= 2, "R(n) = 8R(n/4) + 26M(n/4)");
        
        if (stage === 0) {
            p.fill(100);
            p.noStroke();
            p.text("点击“演示分解”按钮", p.width/2, p.height - 15);
        }
        // No need to call p.loop() or p.noLoop() here, button handler manages it.
    };

    function drawBlockMatrix(x, y, size, divisions, showDivisions, formulaText) {
        p.push();
        p.translate(x, y);
        p.stroke(100);
        p.strokeWeight(1.5);
        p.fill(200, 210, 230); 
        p.rect(0, 0, size, size, 8); // Main matrix box with rounded corners

        if (showDivisions) {
            let subSize = size / divisions;
            for (let i = 0; i < divisions; i++) {
                for (let j = 0; j < divisions; j++) {
                    p.fill(225, 230, 240); 
                    p.stroke(150);
                    p.strokeWeight(1);
                    p.rect(j * subSize, i * subSize, subSize, subSize); // No rounding for inner blocks for sharpness
                    p.fill(80);
                    p.noStroke();
                    p.textSize(10);
                    p.text(`B${i}${j}`, j*subSize + subSize/2, i*subSize + subSize/2);
                }
            }
            p.fill(0); 
            p.noStroke();
            p.textSize(11);
            p.text(formulaText, size/2, size + 15);
        } else {
            p.fill(80);
            p.noStroke();
            p.textSize(16);
            p.text("N x N", size/2, size/2);
        }
        p.pop();
    }
};
new p5(sketch2);

// Animation 3: R(n)/S(n) Ratio Chart
let chart3Instance = null;
function createChart3() {
    const ctx = document.getElementById('chart3').getContext('2d');
    if (chart3Instance) {
        chart3Instance.destroy();
    }
    const n_values = [4, 16, 64, 256, 1024, 4096, 16384]; 
    const ratio_values = [1.0, 0.895, 0.937, 0.946, 0.950, 0.951, 0.951]; // User's original data
    const asymptotic_limit_value = (26/41) / (2/3); // ~0.95118
    const asymptotic_limit = Array(n_values.length).fill(asymptotic_limit_value);
    
    chart3Instance = new Chart(ctx, {
        type: 'line',
        data: {
            labels: n_values.map((n, i) => `4^${i+1}`), // Simplified labels for clarity
            datasets: [{
                label: 'R(n)/S(n) 比率',
                data: ratio_values,
                borderColor: 'rgb(75, 192, 192)',
                backgroundColor: 'rgba(75, 192, 192, 0.1)',
                tension: 0.1,
                fill: true 
            }, {
                label: `渐进比率 (${(asymptotic_limit_value*100).toFixed(1)}%)`,
                data: asymptotic_limit,
                borderColor: 'rgb(255, 99, 132)',
                borderDash: [5, 5],
                tension: 0.1,
                fill: false,
                pointRadius: 0 
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: Math.min(...ratio_values, asymptotic_limit_value) * 0.95, 
                    max: Math.max(...ratio_values, asymptotic_limit_value) * 1.05, 
                    title: { display: true, text: 'R(n)/S(n)' },
                    ticks: { callback: function(value) { return (value * 100).toFixed(1) + '%'; } }
                },
                x: {
                    title: { display: true, text: '矩阵规模 n (log scale implied by 4^k)' } 
                }
            },
            animation: {
                duration: 1500,
            },
            plugins: {
                legend: { position: 'top' },
                tooltip: { mode: 'index', intersect: false }
            }
        }
    });
}
document.getElementById('playBtn3').onclick = createChart3;


// Animation 4: Runtime Comparison Histogram (Simulated)
// Animation 4: Runtime Comparison Histogram (Simulated) - Enhanced Version

// 全局图表实例变量，用于销毁旧图表
let chart4Instance = null;

/**
 * 创建并显示运行时比较直方图。
 */
function createChart4() {
    // 获取canvas元素
    const ctx = document.getElementById('chart4').getContext('2d');

    // 如果已存在图表实例，则先销毁
    if (chart4Instance) {
        chart4Instance.destroy();
    }

    // --- 配置参数 ---
    const SIMULATION_CONFIG = {
        TOTAL_RUNS: 1000, // 模拟运行总次数
        NUM_BINS: 25,     // 直方图的柱子数量
        MIN_RUNTIME: 2.0, // 模拟运行时间的最小值 (秒)
        MAX_RUNTIME: 3.3, // 模拟运行时间的最大值 (秒)
        RXTX: {
            mean: 2.524,  // RXTX 论文中的平均运行时间
            stdDev: 0.09, // RXTX 模拟标准差 (可调整以匹配分布形状)
            color: 'rgba(255, 159, 64, 1)', // 橙色系
            gradientStart: 'rgba(255, 159, 64, 0.85)',
            gradientEnd: 'rgba(255, 120, 30, 0.65)',
            label: 'RXTX 运行时间 (模拟)'
        },
        DEFAULT_BLAS: {
            mean: 2.778, // BLAS 论文中的平均运行时间
            stdDev: 0.11, // BLAS 模拟标准差 (可调整)
            color: 'rgba(54, 162, 235, 1)',  // 蓝色系
            gradientStart: 'rgba(54, 162, 235, 0.85)',
            gradientEnd: 'rgba(30, 120, 200, 0.65)',
            label: '默认BLAS 运行时间 (模拟)'
        },
        FONT_FAMILY: "'Inter', sans-serif", // 统一字体
    };

    // --- 辅助函数 ---

    /**
     * 生成符合类正态分布的随机数据。
     * @param {number} count - 生成数据点的数量。
     * @param {number} mean - 分布的均值。
     * @param {number} stdDev - 分布的标准差。
     * @param {number} minVal - 数据的最小值。
     * @param {number} maxVal - 数据的最大值。
     * @returns {number[]} 生成的数据数组。
     */
    function generateNormalLikeData(count, mean, stdDev, minVal, maxVal) {
        const data = [];
        for (let i = 0; i < count; i++) {
            // 使用 Box-Muller 变换生成正态分布的近似值 (取一个随机数)
            let u = 0, v = 0;
            while (u === 0) u = Math.random(); // 避免 log(0)
            while (v === 0) v = Math.random();
            let num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            num = num * stdDev + mean; // 应用均值和标准差
            num = Math.max(minVal, Math.min(num, maxVal)); // 限制在指定范围内
            data.push(num);
        }
        return data;
    }

    /**
     * 根据原始数据创建直方图的分箱数据。
     * @param {number[]} rawData - 原始数据点数组。
     * @param {number} numBins - 分箱数量。
     * @param {number} minVal - 数据的最小值。
     * @param {number} maxVal - 数据的最大值。
     * @returns {{labels: string[], bins: number[]}} 包含标签和分箱计数的对象。
     */
    function createHistogramFromData(rawData, numBins, minVal, maxVal) {
        const binSize = (maxVal - minVal) / numBins;
        const bins = new Array(numBins).fill(0);
        const labels = [];

        for (let i = 0; i < numBins; i++) {
            const binStart = minVal + i * binSize;
            const binEnd = binStart + binSize;
            // 格式化标签，保留两位小数
            labels.push(`${binStart.toFixed(2)} - ${binEnd.toFixed(2)}s`);
        }

        rawData.forEach(value => {
            let binIndex = Math.floor((value - minVal) / binSize);
            // 处理值等于maxVal的边界情况
            if (value >= maxVal) {
                binIndex = numBins - 1;
            }
            // 确保索引在有效范围内
            if (binIndex >= 0 && binIndex < numBins) {
                bins[binIndex]++;
            }
        });
        return { labels, bins };
    }

    /**
     * 计算数组的基本统计数据 (均值, 中位数, 标准差)。
     * @param {number[]} data - 数值数组。
     * @returns {{mean: number, median: number, stdDev: number}} 统计数据对象。
     */
    function calculateBasicStats(data) {
        if (!data || data.length === 0) {
            return { mean: NaN, median: NaN, stdDev: NaN };
        }
        const n = data.length;
        // 计算均值
        const sum = data.reduce((acc, val) => acc + val, 0);
        const mean = sum / n;

        // 计算中位数
        const sortedData = [...data].sort((a, b) => a - b);
        let median;
        if (n % 2 === 0) {
            median = (sortedData[n / 2 - 1] + sortedData[n / 2]) / 2;
        } else {
            median = sortedData[Math.floor(n / 2)];
        }

        // 计算标准差
        const variance = data.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / n;
        const stdDev = Math.sqrt(variance);

        return { mean, median, stdDev };
    }
    
    /**
     * 创建柱子的渐变背景。
     * @param {CanvasRenderingContext2D} chartCtx - Chart.js的canvas上下文。
     * @param {string} colorStart - 渐变起始颜色。
     * @param {string} colorEnd - 渐变结束颜色。
     * @returns {CanvasGradient} 画布渐变对象。
     */
    function createBarGradient(chartCtx, colorStart, colorEnd) {
        const gradient = chartCtx.createLinearGradient(0, 0, 0, chartCtx.canvas.height * 0.6); // 渐变方向和范围
        gradient.addColorStop(0, colorStart);
        gradient.addColorStop(1, colorEnd);
        return gradient;
    }


    // --- 数据生成与处理 ---
    const rawRxtxData = generateNormalLikeData(
        SIMULATION_CONFIG.TOTAL_RUNS,
        SIMULATION_CONFIG.RXTX.mean,
        SIMULATION_CONFIG.RXTX.stdDev,
        SIMULATION_CONFIG.MIN_RUNTIME,
        SIMULATION_CONFIG.MAX_RUNTIME
    );
    const rawDefaultBlasData = generateNormalLikeData(
        SIMULATION_CONFIG.TOTAL_RUNS,
        SIMULATION_CONFIG.DEFAULT_BLAS.mean,
        SIMULATION_CONFIG.DEFAULT_BLAS.stdDev,
        SIMULATION_CONFIG.MIN_RUNTIME,
        SIMULATION_CONFIG.MAX_RUNTIME
    );

    const rxtxHistogram = createHistogramFromData(rawRxtxData, SIMULATION_CONFIG.NUM_BINS, SIMULATION_CONFIG.MIN_RUNTIME, SIMULATION_CONFIG.MAX_RUNTIME);
    const defaultBlasHistogram = createHistogramFromData(rawDefaultBlasData, SIMULATION_CONFIG.NUM_BINS, SIMULATION_CONFIG.MIN_RUNTIME, SIMULATION_CONFIG.MAX_RUNTIME);
    
    // 确保两个数据集使用相同的标签 (基于RXTX的，或者可以合并两者以获得完整范围)
    const sharedLabels = rxtxHistogram.labels;

    // 计算统计数据
    const rxtxStats = calculateBasicStats(rawRxtxData);
    const blasStats = calculateBasicStats(rawDefaultBlasData);

    // --- Chart.js 配置 ---
    const chartData = {
        labels: sharedLabels,
        datasets: [
            {
                label: SIMULATION_CONFIG.RXTX.label,
                data: rxtxHistogram.bins,
                backgroundColor: createBarGradient(ctx, SIMULATION_CONFIG.RXTX.gradientStart, SIMULATION_CONFIG.RXTX.gradientEnd),
                borderColor: SIMULATION_CONFIG.RXTX.color,
                borderWidth: 1.5,
                borderRadius: { topLeft: 6, topRight: 6 }, // 柱子顶部圆角
                barPercentage: 0.9,    // 柱子宽度百分比
                categoryPercentage: 0.8 // 分类宽度百分比
            },
            {
                label: SIMULATION_CONFIG.DEFAULT_BLAS.label,
                data: defaultBlasHistogram.bins,
                backgroundColor: createBarGradient(ctx, SIMULATION_CONFIG.DEFAULT_BLAS.gradientStart, SIMULATION_CONFIG.DEFAULT_BLAS.gradientEnd),
                borderColor: SIMULATION_CONFIG.DEFAULT_BLAS.color,
                borderWidth: 1.5,
                borderRadius: { topLeft: 6, topRight: 6 },
                barPercentage: 0.9,
                categoryPercentage: 0.8
            }
        ]
    };

    const chartOptions = {
        responsive: true,
        maintainAspectRatio: false,
        layout: {
            padding: { top: 20, right: 20, bottom: 10, left: 10 } // 图表内边距
        },
        scales: {
            y: {
                beginAtZero: true,
                title: {
                    display: true,
                    text: '运行次数 (模拟)',
                    font: {
                        size: 14,
                        family: SIMULATION_CONFIG.FONT_FAMILY,
                        weight: '600'
                    },
                    color: '#4A5568', // 标题颜色 (深灰)
                    padding: { top: 0, bottom: 15 }
                },
                grid: {
                    color: 'rgba(200, 200, 200, 0.3)', // 网格线颜色变浅
                    borderDash: [3, 3], // 虚线网格
                },
                ticks: {
                    font: {
                        family: SIMULATION_CONFIG.FONT_FAMILY,
                        size: 11,
                    },
                    color: '#718096' // 刻度文字颜色 (中灰)
                }
            },
            x: {
                title: {
                    display: true,
                    text: '运行时间区间 (秒)',
                    font: {
                        size: 14,
                        family: SIMULATION_CONFIG.FONT_FAMILY,
                        weight: '600'
                    },
                    color: '#4A5568',
                    padding: { top: 15, bottom: 0 }
                },
                grid: {
                    display: false, // 隐藏X轴的背景网格线
                },
                ticks: {
                    font: {
                        family: SIMULATION_CONFIG.FONT_FAMILY,
                        size: 10, // X轴刻度标签可以小一些
                    },
                    color: '#718096',
                    maxRotation: 45, // 标签过长时旋转
                    minRotation: 0
                }
            }
        },
        plugins: {
            title: { // 添加主标题
                display: true,
                text: 'RXTX 与默认BLAS 运行时间分布对比 (模拟)',
                font: {
                    size: 18,
                    family: SIMULATION_CONFIG.FONT_FAMILY,
                    weight: 'bold'
                },
                color: '#2D3748', // 主标题颜色 (更深灰)
                padding: { top: 0, bottom: 25 }
            },
            legend: {
                position: 'bottom', // 图例位置
                labels: {
                    font: {
                        family: SIMULATION_CONFIG.FONT_FAMILY,
                        size: 12,
                        weight: '500'
                    },
                    color: '#4A5568',
                    usePointStyle: true, // 使用点状图例标记
                    boxWidth: 15, // 图例标记宽度
                    padding: 20 // 图例项之间的间距
                },
                onHover: (event, legendItem, legend) => {
                    const chart = legend.chart;
                    const activeSegment = chart.getDatasetMeta(legendItem.datasetIndex);
                    activeSegment.controller.hoverRadius = (activeSegment.controller.hoverRadius === 0) ? chart.options.elements.bar.hoverBorderWidth + 4 : 0;
                    chart.update();
                     if (event.native.target.style) { // 添加手型光标
                        event.native.target.style.cursor = 'pointer';
                    }
                },
                onLeave: (event, legendItem, legend) => {
                    const chart = legend.chart;
                    const activeSegment = chart.getDatasetMeta(legendItem.datasetIndex);
                    activeSegment.controller.hoverRadius = 0;
                    chart.update();
                    if (event.native.target.style) { // 恢复默认光标
                        event.native.target.style.cursor = 'default';
                    }
                }
            },
            tooltip: {
                enabled: true,
                mode: 'index', // 同时显示同一索引下的所有数据集信息
                intersect: false, // 即使不直接悬停在元素上，只要在附近就显示
                backgroundColor: 'rgba(45, 55, 72, 0.92)', // 工具提示背景色 (深灰，半透明)
                titleFont: {
                    family: SIMULATION_CONFIG.FONT_FAMILY,
                    size: 14,
                    weight: 'bold'
                },
                titleColor: '#E2E8F0', // 标题文字颜色 (浅灰)
                bodyFont: {
                    family: SIMULATION_CONFIG.FONT_FAMILY,
                    size: 12
                },
                bodyColor: '#CBD5E0', // 内容文字颜色 (更浅灰)
                footerFont: {
                    family: SIMULATION_CONFIG.FONT_FAMILY,
                    style: 'italic'
                },
                padding: 12, // 内边距
                cornerRadius: 6, // 圆角
                caretPadding: 10, // 箭头与提示框的距离
                caretSize: 8,     // 箭头大小
                displayColors: true, // 显示颜色小方块
                borderColor: 'rgba(255,255,255,0.2)',
                borderWidth: 1,
                callbacks: { // 自定义工具提示内容
                    title: function(tooltipItems) {
                        return `时间区间: ${tooltipItems[0].label}`;
                    },
                    label: function(context) {
                        let label = context.dataset.label || '';
                        if (label) {
                            label += ': ';
                        }
                        if (context.parsed.y !== null) {
                            label += `${context.parsed.y} 次 (占比 ${(context.parsed.y / SIMULATION_CONFIG.TOTAL_RUNS * 100).toFixed(1)}%)`;
                        }
                        return label;
                    }
                }
            },
            // 自定义插件：绘制均值线
            meanLinePlugin: {
                id: 'meanLinePlugin',
                afterDraw: (chart) => {
                    const yAxis = chart.scales.y;
                    const xAxis = chart.scales.x;
                    const chartArea = chart.chartArea;
                    const pluginCtx = chart.ctx;

                    [{ mean: rxtxStats.mean, color: SIMULATION_CONFIG.RXTX.color, label: 'RXTX 均值' },
                     { mean: blasStats.mean, color: SIMULATION_CONFIG.DEFAULT_BLAS.color, label: 'BLAS 均值' }
                    ].forEach((item, index) => {
                        if (isNaN(item.mean)) return;

                        // 找到均值对应的X轴位置
                        // 这需要一点近似，因为均值可能不在bin的中心
                        let xPos = null;
                        for(let i=0; i < chart.data.labels.length; i++) {
                            const labelRange = chart.data.labels[i].split(' - ').map(s => parseFloat(s.replace('s','')));
                            if(item.mean >= labelRange[0] && item.mean < labelRange[1]) {
                                // 尝试在bin内按比例插值
                                const binCenter = xAxis.getPixelForTick(i);
                                const nextBinCenter = (i + 1 < xAxis.ticks.length) ? xAxis.getPixelForTick(i+1) : binCenter + (binCenter - xAxis.getPixelForTick(i-1));
                                const binWidthPx = Math.abs(nextBinCenter - binCenter);
                                const proportionInBin = (item.mean - labelRange[0]) / (labelRange[1] - labelRange[0]);
                                xPos = binCenter - binWidthPx/2 + proportionInBin * binWidthPx;

                                // 如果用getPixelForValue, 需要原始数据映射到x轴
                                // xPos = xAxis.getPixelForValue(item.mean); // 这可能不直接工作，因为x轴是分类轴
                                break;
                            }
                        }
                        // 如果找不到精确的bin，就取最接近的bin的中心
                         if (xPos === null) {
                            let closestBinIndex = 0;
                            let minDist = Infinity;
                            chart.data.labels.forEach((label, i) => {
                                const binMid = (parseFloat(label.split(' - ')[0]) + parseFloat(label.split(' - ')[1].replace('s',''))) / 2;
                                const dist = Math.abs(item.mean - binMid);
                                if (dist < minDist) {
                                    minDist = dist;
                                    closestBinIndex = i;
                                }
                            });
                            xPos = xAxis.getPixelForTick(closestBinIndex);
                        }


                        if (xPos !== null && xPos >= chartArea.left && xPos <= chartArea.right) {
                            pluginCtx.save();
                            pluginCtx.beginPath();
                            pluginCtx.moveTo(xPos, chartArea.top + 5);
                            pluginCtx.lineTo(xPos, chartArea.bottom - 5);
                            pluginCtx.lineWidth = 2;
                            pluginCtx.strokeStyle = item.color;
                            pluginCtx.setLineDash([6, 3]); // 虚线样式
                            pluginCtx.stroke();
                            pluginCtx.setLineDash([]); // 重置虚线

                            // 绘制均值线标签
                            pluginCtx.fillStyle = item.color;
                            pluginCtx.font = `600 10px ${SIMULATION_CONFIG.FONT_FAMILY}`;
                            pluginCtx.textAlign = xPos > chartArea.left + 50 ? 'right' : 'left';
                            pluginCtx.fillText(`${item.label}: ${item.mean.toFixed(3)}s`, xPos + (xPos > chartArea.left + 50 ? -5 : 5) , chartArea.top + 10 + index * 15);
                            pluginCtx.restore();
                        }
                    });
                }
            }
        },
        animation: { // 更丰富的动画效果
            duration: 1800, // 动画持续时间
            easing: 'easeInOutQuart', // 缓动函数
            onProgress: function(animation) {
                // 可以在这里添加逐帧动画效果，例如让柱子有弹性效果
            },
            delay: (context) => { // 每个数据集或柱子可以有不同的延迟
                let delay = 0;
                if (context.type === 'data' && context.mode === 'default' && !context.dropped) {
                    delay = context.dataIndex * 50 + context.datasetIndex * 200; // 错开动画
                }
                return delay;
            },
        },
        hover: { // 悬停交互
            mode: 'nearest',
            intersect: true,
            animationDuration: 200, // 悬停动画时长
        },
        elements: {
            bar: {
                borderSkipped: 'bottom', // 底部不渲染边框，使圆角更好看
                hoverBackgroundColor: (context) => context.dataset.borderColor.replace('1)', '0.9)'), // 悬停时更亮
                hoverBorderColor: (context) => context.dataset.borderColor,
                hoverBorderWidth: 2.5
            }
        }
    };

    // --- 创建图表实例 ---
    chart4Instance = new Chart(ctx, {
        type: 'bar',
        data: chartData,
        options: chartOptions,
        plugins: [chartOptions.plugins.meanLinePlugin] // 注册自定义插件
    });

    // --- 更新统计信息显示 (如果HTML中有对应元素) ---
    const statsDiv = document.getElementById('chart4Stats');
    if (statsDiv) {
        statsDiv.innerHTML = `
            <div style="display: flex; justify-content: space-around; margin-top:10px;">
                <div style="text-align: left; padding: 5px 15px; background-color: rgba(255, 159, 64, 0.1); border-left: 3px solid ${SIMULATION_CONFIG.RXTX.color}; border-radius: 4px;">
                    <strong>${SIMULATION_CONFIG.RXTX.label.split(' (')[0]}:</strong><br>
                    均值: ${rxtxStats.mean.toFixed(3)}s<br>
                    中位数: ${rxtxStats.median.toFixed(3)}s<br>
                    标准差: ${rxtxStats.stdDev.toFixed(3)}s
                </div>
                <div style="text-align: left; padding: 5px 15px; background-color: rgba(54, 162, 235, 0.1); border-left: 3px solid ${SIMULATION_CONFIG.DEFAULT_BLAS.color}; border-radius: 4px;">
                    <strong>${SIMULATION_CONFIG.DEFAULT_BLAS.label.split(' (')[0]}:</strong><br>
                    均值: ${blasStats.mean.toFixed(3)}s<br>
                    中位数: ${blasStats.median.toFixed(3)}s<br>
                    标准差: ${blasStats.stdDev.toFixed(3)}s
                </div>
            </div>
        `;
    }
} // createChart4 函数结束

// 确保按钮存在并绑定事件
const playButton4 = document.getElementById('playBtn4');
if (playButton4) {
    playButton4.onclick = createChart4;
} else {
    console.warn("按钮 'playBtn4' 未在HTML中找到。图表可能无法通过点击按钮生成。");
    // 可以考虑在DOM加载完成后自动调用一次 createChart4() 作为备选方案
    // document.addEventListener('DOMContentLoaded', createChart4);
}

 createChart4(); 


// Animation 5: RXTX 算法发现流程示意 (增强版)
const sketch5 = (p) => {
    // 画布基本设置
    const canvasWidth = 450; // 画布宽度调整
    const canvasHeight = 500; // 画布高度增加，为更丰富的视觉效果提供空间

    // 流程步骤相关配置
    const totalSteps = 6; // 总步骤数量
    const labels = [ // 各步骤的标签文本
        "需求识别 (XXᵀ 计算)",
        "RL 代理提议候选项",
        "MILP-A 枚举关系",
        "MILP-B 选择子集",
        "LNS 优化迭代",
        "RXTX 算法完成"
    ];
    const stepDetails = [ // 各步骤的详细描述（用于工具提示）
        "识别计算XX^T的需求及其在各领域的重要性，明确优化目标。",
        "强化学习(RL)代理探索并提出一组可能用于构建XX^T计算的秩-1双线性乘积候选项。",
        "第一个混合整数线性规划(MILP-A)模型在候选项和目标表达式之间，系统地枚举并生成大量潜在的线性关系。",
        "第二个MILP-B模型从MILP-A生成的众多关系中，智能选择一个最小的乘积子集，确保完整覆盖XX^T的所有目标表达式。",
        "在大邻域搜索(LNS)框架下，结合RL和MILP进行迭代优化，不断探索和改进计算方案，寻找更高效的组合。",
        "经过多轮优化，最终确定RXTX算法的具体形式。该算法通过新颖的分解和组合，显著减少了运算次数，提升了计算效率。"
    ];

    // 动画状态变量
    let currentStepIndex = 0; // 当前激活到的步骤索引
    let stepBoxes = []; // 存储所有步骤框对象的数组
    let animatedArrows = []; // 存储所有连接箭头的数组

    // 粒子效果数组
    let starParticles = []; // 背景星光粒子
    let mouseSparkles = []; // 鼠标交互闪光粒子
    let activationBursts = []; // 步骤激活时的爆发粒子

    const maxStarParticles = 50; // 最大背景星光粒子数量
    const maxMouseSparkles = 15; // 最大鼠标交互闪光数量

    // 工具提示对象
    let tooltip = {
        visible: false,
        x: 0,
        y: 0,
        targetX: 0,
        targetY: 0,
        content: "",
        alpha: 0,
        width: 200, // 工具提示框宽度增加
        height: 80  // 工具提示框高度增加
    };

    // 缓动函数 (easeInOutCubic)
    function easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    // --- 粒子类定义 ---

    // 背景星光粒子类
    class StarParticle {
        constructor() {
            this.pos = p.createVector(p.random(p.width), p.random(p.height));
            this.vel = p.createVector(0, p.random(0.1, 0.5)); // 向下缓慢移动
            this.size = p.random(1, 2.5);
            this.initialAlpha = p.random(50, 150);
            this.alpha = this.initialAlpha;
            this.life = p.random(200, 400); // 较长的生命周期
            this.maxLife = this.life;
        }

        update() {
            this.pos.add(this.vel);
            this.life--;
            // 淡入淡出效果
            const fadeInDuration = this.maxLife * 0.2;
            const fadeOutDuration = this.maxLife * 0.3;
            if (this.maxLife - this.life < fadeInDuration) {
                this.alpha = p.map(this.maxLife - this.life, 0, fadeInDuration, 0, this.initialAlpha);
            } else if (this.life < fadeOutDuration) {
                this.alpha = p.map(this.life, 0, fadeOutDuration, 0, this.initialAlpha);
            } else {
                this.alpha = this.initialAlpha;
            }

            if (this.life <= 0 || this.pos.y > p.height + this.size) {
                // 重置粒子到顶部
                this.pos.x = p.random(p.width);
                this.pos.y = -this.size;
                this.life = p.random(200, 400);
                this.maxLife = this.life;
                this.initialAlpha = p.random(50, 150);
                this.vel = p.createVector(0, p.random(0.1, 0.5));
            }
        }

        display() {
            p.noStroke();
            p.fill(220, 230, 255, this.alpha * 0.7); // 淡蓝色星光
            p.ellipse(this.pos.x, this.pos.y, this.size);
        }
    }

    // 鼠标交互闪光粒子类
    class MouseSparkle {
        constructor(x, y) {
            this.pos = p.createVector(x, y);
            this.vel = p5.Vector.random2D(p).mult(p.random(1, 3)); // p5.Vector.random2D()
            this.acc = p.createVector(0, 0.05); // 轻微重力
            this.life = p.random(30, 60); // 较短生命周期
            this.size = p.random(2, 4);
            this.color = p.color(p.random(200, 255), p.random(220, 255), 255, p.random(150, 200));
        }

        update() {
            this.vel.add(this.acc);
            this.pos.add(this.vel);
            this.life -= 1.5;
            this.size *= 0.97; // 逐渐变小
        }

        display() {
            p.noStroke();
            p.fill(this.color.levels[0], this.color.levels[1], this.color.levels[2], this.life);
            p.ellipse(this.pos.x, this.pos.y, this.size);
        }

        isDead() {
            return this.life <= 0 || this.size <= 0.1;
        }
    }
    
    // 步骤激活爆发粒子类
    class ActivationBurstParticle {
        constructor(x, y) {
            this.pos = p.createVector(x, y);
            this.vel = p5.Vector.random2D(p).mult(p.random(2, 5)); // 爆发速度稍快
            this.life = p.random(40, 80);
            this.size = p.random(3, 7);
            this.color = p.color(p.random(100, 180), p.random(200, 255), p.random(220, 255), 200); // 偏蓝绿色调
            this.drag = 0.96; // 模拟空气阻力
        }

        update() {
            this.vel.mult(this.drag);
            this.pos.add(this.vel);
            this.life -= 1;
            this.size *= 0.98;
        }

        display() {
            p.noStroke();
            p.fill(this.color.levels[0], this.color.levels[1], this.color.levels[2], this.life * 2); // 透明度与生命周期关联
            p.ellipse(this.pos.x, this.pos.y, this.size);
        }

        isDead() {
            return this.life <= 0 || this.size < 0.5;
        }
    }


    // --- 步骤框类 (StepBox) ---
    class StepBox {
        constructor(index, x, y, w, h, label, detail) {
            this.index = index;
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
            this.label = label;
            this.detail = detail; // 详细信息，用于工具提示

            this.alpha = 0; // 用于淡入动画
            this.targetAlpha = 0;
            this.scale = 0.8; // 用于入场缩放动画
            this.targetScale = 1.0;
            this.hoverAmount = 0; // 悬停时的发光/位移量
            this.yOffset = 0; // 悬停时的Y轴位移

            this.isActive = false; // 当前步骤是否为活动步骤
            this.isCompleted = false; // 步骤是否已完成（下一个步骤已激活）
            this.glowAlpha = 0; // 激活时的辉光效果透明度
        }

        // 激活步骤
        activate() {
            this.targetAlpha = 255;
            this.targetScale = 1.0;
            this.isActive = true;
            this.isCompleted = false; // 重置完成状态
            // 创建爆发粒子效果
            for (let i = 0; i < 20; i++) {
                activationBursts.push(new ActivationBurstParticle(this.x, this.y));
            }
        }

        // 标记为已完成
        complete() {
            this.isActive = false;
            this.isCompleted = true;
        }

        // 重置状态
        reset() {
            this.alpha = 0;
            this.targetAlpha = 0;
            this.scale = 0.8;
            this.targetScale = 1.0;
            this.isActive = false;
            this.isCompleted = false;
            this.glowAlpha = 0;
        }

        // 更新状态和动画
        update() {
            // 平滑过渡 alpha 和 scale
            this.alpha = p.lerp(this.alpha, this.targetAlpha, 0.1);
            this.scale = p.lerp(this.scale, this.targetScale, 0.15);

            // 悬停效果更新
            let targetHover = 0;
            let targetYOffset = 0;
            if (this.isMouseOver() && this.alpha > 200) {
                targetHover = 1;
                targetYOffset = -3; // 鼠标悬停时轻微上移
            }
            this.hoverAmount = p.lerp(this.hoverAmount, targetHover, 0.2);
            this.yOffset = p.lerp(this.yOffset, targetYOffset, 0.2);
            
            // 激活辉光效果
            if(this.isActive && this.alpha > 250) {
                this.glowAlpha = p.lerp(this.glowAlpha, 150, 0.1);
            } else {
                this.glowAlpha = p.lerp(this.glowAlpha, 0, 0.1);
            }
        }

        // 检测鼠标是否悬停在框上
        isMouseOver() {
            return p.mouseX > this.x - this.w / 2 && p.mouseX < this.x + this.w / 2 &&
                   p.mouseY > this.y - this.h / 2 + this.yOffset && p.mouseY < this.y + this.h / 2 + this.yOffset;
        }

        // 显示步骤框
        display() {
            p.push();
            p.translate(this.x, this.y + this.yOffset); // 应用悬停位移
            p.scale(this.scale); // 应用缩放动画

            // 外部辉光 (激活或悬停时)
            if (this.glowAlpha > 10 || (this.hoverAmount > 0.1 && this.alpha > 200)) {
                p.noStroke();
                let glowColor = this.isActive ? p.color(100, 180, 255, this.glowAlpha * this.hoverAmount * 0.7) : p.color(150, 200, 255, this.hoverAmount * 80);
                if(this.isActive) glowColor = p.color(100, 180, 255, this.glowAlpha);

                p.drawingContext.shadowBlur = 15 + this.hoverAmount * 10 + (this.isActive ? 10 : 0);
                p.drawingContext.shadowColor = glowColor.toString();
                // 绘制一个稍微大一点的矩形作为辉光基础，但设为透明，仅利用阴影
                p.fill(0,0); 
                p.rect(-this.w / 2, -this.h / 2, this.w, this.h, 10);
            }
            
            // 重置阴影，绘制主框体
            p.drawingContext.shadowBlur = 0;

            // 绘制阴影 (更柔和)
            p.noStroke();
            p.fill(0, this.alpha * 0.08 * (1 + this.hoverAmount * 0.5)); // 动态阴影
            p.rect(-this.w / 2 + 3, -this.h / 2 + 3, this.w, this.h, 10);

            // 绘制框体背景渐变
            const grad = p.drawingContext.createLinearGradient(-this.w / 2, -this.h / 2, -this.w / 2, this.h / 2);
            let baseColor1 = this.isCompleted ? p.color(200, 210, 220, this.alpha) : p.color(238, 242, 248, this.alpha);
            let baseColor2 = this.isCompleted ? p.color(180, 190, 200, this.alpha) : p.color(215, 225, 240, this.alpha);
            if (this.isActive) {
                 baseColor1 = p.color(220, 235, 255, this.alpha); // 激活时更亮
                 baseColor2 = p.color(190, 215, 245, this.alpha);
            }
            grad.addColorStop(0, baseColor1.toString());
            grad.addColorStop(1, baseColor2.toString());
            p.drawingContext.fillStyle = grad;

            p.stroke(170, 180, 200, this.alpha * 0.8); // 边框颜色
            p.strokeWeight(this.isActive ? 1.5 : 1); // 激活时边框加粗
            p.rect(-this.w / 2, -this.h / 2, this.w, this.h, 10); // 圆角矩形

            // 绘制文本
            p.noStroke();
            let textColor = this.isCompleted ? p.color(100, 110, 120, this.alpha) : p.color(40, 60, 80, this.alpha);
            if (this.isActive) {
                textColor = p.color(20, 40, 70, this.alpha); // 激活时文本更深
            }
            p.fill(textColor);
            p.textSize(this.isActive ? 12.5 : 12); // 激活时文本稍大
            p.textStyle(this.isActive ? p.BOLD : p.NORMAL);
            p.text(this.label, 0, 0);
            p.textStyle(p.NORMAL);


            // 如果已完成，显示一个小的完成标记 (可选)
            if (this.isCompleted && this.alpha > 200) {
                p.fill(80, 180, 120, this.alpha * 0.8); // 绿色标记
                p.noStroke();
                p.ellipse(this.w / 2 - 12, -this.h/2 + 12, 8, 8);
            }

            p.pop();
        }
    }

    // --- 动画箭头类 (AnimatedArrow) ---
    class AnimatedArrow {
        constructor(startX, startY, endX, endY) {
            this.startX = startX;
            this.startY = startY;
            this.endX = endX;
            this.endY = endY;
            this.progress = 0; // 动画进度 (0 to 1)
            this.targetProgress = 0;
            this.alpha = 0; // 箭头整体透明度
            this.glowProgress = 0; // 箭头光效动画
        }

        // 开始动画
        start() {
            this.targetProgress = 1;
            this.alpha = 255; // 箭头出现
        }
        
        // 重置状态
        reset() {
            this.progress = 0;
            this.targetProgress = 0;
            this.alpha = 0;
            this.glowProgress = 0;
        }

        // 更新动画状态
        update() {
            this.progress = p.lerp(this.progress, this.targetProgress, 0.08); // 平滑过渡进度
            if (this.targetProgress > 0.5 && this.progress > 0.5) { // 当箭头过半时开始光效
                this.glowProgress = (this.glowProgress + 0.02) % 1; // 循环光效
            }
        }

        // 显示箭头
        display() {
            if (this.progress <= 0.01 || this.alpha < 10) return;

            p.push();
            const currentX2 = p.lerp(this.startX, this.endX, this.progress);
            const currentY2 = p.lerp(this.startY, this.endY, this.progress);

            // 绘制箭头光晕 (在主线条之下)
            p.strokeWeight(8 + p.sin(this.glowProgress * p.TWO_PI) * 2); // 动态粗细的光晕
            p.stroke(150, 200, 255, this.alpha * 0.2 * this.progress * (p.sin(this.glowProgress * p.TWO_PI) * 0.5 + 0.5) ); // 淡蓝色光晕
            p.line(this.startX, this.startY, currentX2, currentY2);

            // 绘制箭头主线条
            const interColor = p.lerpColor(p.color(120, 140, 160, 0), p.color(80, 100, 120, this.alpha), this.progress);
            p.stroke(interColor);
            p.strokeWeight(2.5 + this.progress * 1); // 箭头线条随进度略微变粗
            p.line(this.startX, this.startY, currentX2, currentY2);

            // 绘制箭头头部 (当箭头快要画完时)
            if (this.progress > 0.9) {
                const headSize = 10 + this.progress * 2;
                const angle = p.atan2(this.endY - this.startY, this.endX - this.startX);
                p.push();
                p.translate(currentX2, currentY2);
                p.rotate(angle);
                p.noStroke();
                p.fill(interColor);
                p.triangle(0, 0, -headSize, -headSize / 2.5, -headSize, headSize / 2.5);
                p.pop();
            }
            p.pop();
        }
    }
    
    // --- p5.js 主函数 ---
    p.setup = () => {
        const canvas = p.createCanvas(canvasWidth, canvasHeight);
        canvas.parent("canvasContainer5"); // 确保父容器ID正确
        p.textAlign(p.CENTER, p.CENTER);
        p.textFont('Inter, sans-serif'); // 使用与页面一致的字体

        // 初始化背景星光粒子
        for (let i = 0; i < maxStarParticles; i++) {
            starParticles.push(new StarParticle());
        }

        // 初始化步骤框和箭头
        const boxWidth = 280; // 步骤框宽度
        const boxHeight = 48;  // 步骤框高度
        const totalContentHeight = totalSteps * boxHeight + (totalSteps - 1) * (boxHeight * 0.5); // 估算内容总高度
        const startYOffset = (p.height - totalContentHeight) / 2 + 20; // 垂直居中偏移
        
        for (let i = 0; i < totalSteps; i++) {
            const yPos = startYOffset + i * (boxHeight + boxHeight * 0.45); // 增加步骤框间距
            stepBoxes.push(new StepBox(i, p.width / 2, yPos, boxWidth, boxHeight, labels[i], stepDetails[i]));
            
            if (i > 0) {
                const prevBox = stepBoxes[i-1];
                animatedArrows.push(new AnimatedArrow(
                    prevBox.x, prevBox.y + prevBox.h / 2 + 5, // 从上一个框底部发出
                    stepBoxes[i].x, stepBoxes[i].y - stepBoxes[i].h / 2 - 5  // 指向当前框顶部
                ));
            }
        }
        
        // 绑定按钮事件
        document.getElementById("playBtn5").onclick = resetAnimation;
        document.getElementById("nextStepBtn5").onclick = advanceStep;

        resetAnimation(); // 初始化动画状态
        p.loop(); // 确保动画循环启动
    };

    // 重置动画
    function resetAnimation() {
        currentStepIndex = 0;
        stepBoxes.forEach(box => box.reset());
        animatedArrows.forEach(arrow => arrow.reset());
        
        stepBoxes[0].activate(); // 激活第一个步骤
        activationBursts = []; // 清空爆发粒子
        tooltip.visible = false;
        tooltip.alpha = 0;
        if (!p.isLooping()) p.loop();
    }

    // 前进一步动画
    function advanceStep() {
        if (currentStepIndex < totalSteps - 1) {
            stepBoxes[currentStepIndex].complete(); // 将当前步骤标记为完成
            currentStepIndex++;
            stepBoxes[currentStepIndex].activate(); // 激活下一个步骤
            if (currentStepIndex > 0) {
                animatedArrows[currentStepIndex - 1].start(); // 启动连接到新步骤的箭头动画
            }
        }
        if (!p.isLooping()) p.loop();
    }

    p.draw = () => {
        p.background(25, 30, 50); // 深色科技感背景

        // 管理和绘制背景星光粒子
        starParticles.forEach(sp => {
            sp.update();
            sp.display();
        });

        // 管理和绘制鼠标交互闪光粒子
        if (p.mouseIsPressed) { // 或者 p.frameCount % N === 0 来持续产生
             if(mouseSparkles.length < maxMouseSparkles) {
                mouseSparkles.push(new MouseSparkle(p.mouseX, p.mouseY));
             }
        }
        for (let i = mouseSparkles.length - 1; i >= 0; i--) {
            mouseSparkles[i].update();
            mouseSparkles[i].display();
            if (mouseSparkles[i].isDead()) {
                mouseSparkles.splice(i, 1);
            }
        }
        
        // 管理和绘制步骤激活爆发粒子
        for (let i = activationBursts.length - 1; i >= 0; i--) {
            activationBursts[i].update();
            activationBursts[i].display();
            if (activationBursts[i].isDead()) {
                activationBursts.splice(i, 1);
            }
        }

        // 更新和显示箭头
        animatedArrows.forEach(arrow => {
            arrow.update();
            arrow.display();
        });

        // 更新和显示步骤框
        let somethingHovered = false;
        stepBoxes.forEach(box => {
            box.update();
            box.display();
            if (box.isMouseOver() && box.alpha > 200) {
                somethingHovered = true;
                tooltip.content = box.detail;
                tooltip.targetX = p.mouseX + 15;
                tooltip.targetY = p.mouseY - tooltip.height / 2 - 10; // 调整工具提示位置

                // 确保工具提示在画布内
                if (tooltip.targetX + tooltip.width > p.width - 10) {
                    tooltip.targetX = p.mouseX - tooltip.width - 15;
                }
                if (tooltip.targetY < 10) {
                    tooltip.targetY = 10;
                }
                if (tooltip.targetY + tooltip.height > p.height - 10) {
                    tooltip.targetY = p.height - 10 - tooltip.height;
                }
                tooltip.visible = true;
            }
        });
        
        // 工具提示的平滑出现/消失
        if (tooltip.visible && somethingHovered) {
            tooltip.alpha = p.lerp(tooltip.alpha, 245, 0.2); // 目标透明度提高
            tooltip.x = p.lerp(tooltip.x, tooltip.targetX, 0.2);
            tooltip.y = p.lerp(tooltip.y, tooltip.targetY, 0.2);
        } else {
            tooltip.alpha = p.lerp(tooltip.alpha, 0, 0.25);
            if (tooltip.alpha < 10) tooltip.visible = false;
        }

        // 绘制工具提示
        if (tooltip.alpha > 10) {
            p.push();
            p.fill(30, 35, 60, tooltip.alpha * 0.95); // 深色背景，高透明度
            p.stroke(100, 130, 180, tooltip.alpha * 0.8); // 边框
            p.strokeWeight(1);
            p.rect(tooltip.x, tooltip.y, tooltip.width, tooltip.height, 8); // 圆角
            
            p.fill(220, 230, 240, tooltip.alpha); // 亮色文本
            p.noStroke();
            p.textSize(11); // 文本大小调整
            p.textAlign(p.LEFT, p.TOP);
            p.textLeading(14); // 行距调整
            p.text(tooltip.content, tooltip.x + 12, tooltip.y + 10, tooltip.width - 20, tooltip.height - 20);
            p.pop();
        }

        // 检查是否所有动画都已完成，如果完成则停止循环以节省资源
        let allAnimationsDone = true;
        if (stepBoxes[totalSteps - 1].alpha < 250 || !stepBoxes[totalSteps - 1].isCompleted && currentStepIndex !== totalSteps -1) {
             allAnimationsDone = false;
        }
        for (let i = 0; i < animatedArrows.length; i++) {
            if (stepBoxes[i+1].isActive && animatedArrows[i].progress < 0.99) { // 检查对应箭头是否完成
                allAnimationsDone = false;
                break;
            }
        }
        // 如果是最后一步，并且最后一步的alpha值已经达到目标值，则认为动画完成
        if (currentStepIndex === totalSteps - 1 && stepBoxes[totalSteps - 1].alpha >= 250) {
             // allAnimationsDone = true; // 这一行似乎多余，因为上面的条件已经能判断
        } else if (currentStepIndex < totalSteps -1) { // 如果不是最后一步，则动画未完成
            allAnimationsDone = false;
        }


        if (allAnimationsDone && p.isLooping()) {
            // p.noLoop(); // 暂时注释掉noLoop，以便交互和粒子效果持续
        }
    };
};

// 确保在HTML加载完成后再实例化p5 sketch
// 这通常由将<script>标签放在<body>底部或使用DOMContentLoaded来处理
new p5(sketch5);

// Ensure charts are drawn if their buttons were already clicked and page reloaded/script re-run
// Or simply prompt user to click. For now, let's keep it to button clicks.
// If you want charts to auto-load if previously drawn, you'd need localStorage or similar.
</script>

</body>
</html>
```

I've made the visual styling a bit more modern and consistent across the animations. The particle system in Animation 5 is now more subtle. Tooltips provide details for each step in Animation 5. The animation flow and button controls should be more reliable now.

You can try running this updated HTML. Let me know if you have any more questions or need further adjustmen
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>微软Discovery：无毒冷却剂的物理逻辑与AI创革 (动画版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&family=ZCOOL+XiaoWei&family=LXGW+WenKai+Mono+TC&display=swap" rel="stylesheet">
    <style>
        /* Custom styles to complement Tailwind and meet specific requirements */
        body {
            font-family: 'LXGW WenKai Mono TC', 'Noto Sans SC', sans-serif; /* Lively and readable Chinese font */
            font-size: 1.125rem; /* Tailwind's text-lg, base for "三号" feel */
            line-height: 1.9; /* Increased for better readability and spaciousness */
            background-color: #f3f4f6; /* Tailwind's gray-100, very light and clean */
            color: #1f2937; /* Tailwind's gray-800 */
        }

        h1, h2, h3 {
            font-family: 'ZCOOL XiaoWei', cursive; /* A more lively font for headings */
            color: #1e3a8a; /* Tailwind's blue-800 */
        }

        .content-card {
            background-color: white;
            border-radius: 16px; /* Softer, more modern rounded corners */
            padding: 2.5rem; /* More generous padding */
            margin-bottom: 2.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.07), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Softer shadow */
        }

        .highlight {
            color: #c2410c; /* Tailwind's orange-700 */
            font-weight: 700; /* Bold for highlights */
            background-color: #fff7ed; /* Tailwind's orange-50, subtle highlight background */
            padding: 0.1em 0.3em;
            border-radius: 4px;
        }
        
        strong.key-phrase {
            color: #1d4ed8; /* Tailwind's blue-700 */
            font-weight: 700;
            border-bottom: 3px solid #93c5fd; /* Tailwind's blue-300, thicker underline */
            padding-bottom: 2px;
        }

        /* Styling for P5.js canvas containers and buttons */
        .animation-container {
            margin-bottom: 2.5rem;
            padding: 2rem;
            border: 1px solid #d1d5db; /* Tailwind's gray-300 */
            border-radius: 12px;
            background-color: #f9fafb; /* Tailwind's gray-50 */
        }

        .animation-canvas-wrapper {
            width: 100%;
            height: 380px; /* Standardized height for these new animations */
            margin-bottom: 1.5rem;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            background-color: #e5e7eb; /* Light gray background for canvas area */
        }
        
        .animation-canvas-wrapper canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        /* Specific canvas wrapper IDs for this document */
        #problemPfasCanvasWrapper,
        #discoveryProcessCanvasWrapper,
        #molecularScreeningCanvasWrapper,
        #iterativeLearningCanvasWrapper,
        #coolantSolutionCanvasWrapper {
            /* Height is already set by .animation-canvas-wrapper, can be overridden if needed */
        }
        
        .control-button {
            background-color: #2563eb; /* Tailwind's blue-600 */
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-size: 1rem; /* Slightly larger button text */
            margin-right: 0.75rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .control-button:hover {
            background-color: #1d4ed8; /* Tailwind's blue-700 */
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .control-button:active {
            transform: translateY(0px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .container {
            max-width: 1100px; /* Slightly wider for A3 feel */
            margin-left: auto;
            margin-right: auto;
            padding: 1.5rem;
        }
        
        @media (min-width: 768px) {
            .container {
                padding: 2.5rem;
            }
            body {
                 font-size: 1.375rem; /* Tailwind's text-xl to text-2xl for "三号" on larger screens */
            }
        }
        .text-shadow {
            text-shadow: 1px 1px 3px rgba(0,0,0,0.1);
        }
        .subtle-border {
            border: 1px solid #e5e7eb; /* gray-200 */
        }
        /* Additional comment lines for length */
        /* Ensuring all elements have good contrast and readability */
        /* Font hierarchy is important for visual appeal */
        /* Spacing (margin, padding) is generous for a clean look */
    </style>
</head>
<body class="antialiased">

    <div class="container py-10">
        <header class="text-center mb-16">
            <h1 class="text-5xl md:text-6xl font-bold mb-6 text-shadow">AI炼金术：微软Discovery与<span class="highlight">无PFAS冷却剂</span>的诞生</h1>
            <p class="text-xl text-gray-700">从物理逻辑视角剖析智能科学发现的革命性突破</p>
        </header>

        <section class="content-card mb-16">
            <h2 class="text-3xl md:text-4xl font-semibold mb-8">解读：AI驱动下的科学“相变”</h2>
            <article class="text-gray-800 space-y-7 leading-relaxed">
                <p>在微软Build 2025的舞台上，John KChemker（化学负责人）演示的Microsoft Discovery平台及其在<strong class="key-phrase">无PFAS浸没式冷却剂</strong>发现上的应用，不仅是一项技术成就，更昭示着科学研究范式的一次深刻“相变”。从物理与逻辑的视角审视，这一过程宛如一场由AI精心调控的“化学反应”，在巨大的可能性空间中，以惊人的效率催化出理想的“产物”。</p>

                <p>首先，问题的提出本身具有明确的“物理边界”与“化学约束”。数据中心散热是<strong class="key-phrase">能量耗散</strong>的物理挑战，而传统PFAS冷却剂的环境危害则是不可接受的“化学副作用”。目标是寻找一种具有特定沸点、介电常数等物理化学性质，且环境友好的新物质。这构成了一个多维度、高复杂度的“优化问题”，传统试错法如同在浩瀚宇宙中盲目搜寻特定星球，效率低下。</p>

                <p>Microsoft Discovery平台的介入，引入了全新的“作用力”与“催化剂”。其核心逻辑是<strong class="key-phrase">“知识图谱驱动的图RAG (GraphRAG)”</strong>与“多智能体协作”。这并非简单的信息检索，而是对海量科学文献（公共与内部）进行深度理解和结构化，形成一个动态的“知识势能场”。智能体在这个场中，能够进行<strong class="key-phrase">“有指导的探索”</strong>，而非随机碰撞。它们如同拥有了“化学键合规则”的感知能力，能识别潜在的分子结构和性质关联。</p>

                <p>“假设生成”阶段，可以看作是AI在模拟<strong class="key-phrase">“分子组合的量子涨落”</strong>。但与自然界的随机性不同，AI的生成是基于从知识图谱中学习到的模式和约束，更有方向性。数百万级别的候选分子被提出，这本身就是一种“高通量筛选”的计算模拟。这背后是强大的“第一性原理计算”与“机器学习模型”的结合，AI模型通过学习已知数据，预测未知分子的性质，这大大缩减了需要进行昂贵物理实验的候选范围，如同用<strong class="key-phrase">“计算显微镜”</strong>预先观察分子的行为。</p>

                <p>“实验与验证”阶段，虽然最终仍需物理合成与测试，但Discovery平台通过<strong class="key-phrase">“持续迭代学习循环”</strong>（generating candidates, simulating them, and learning from the results）极大地加速了这一过程。这类似于物理实验中的反馈控制系统：智能体生成方案 -> 模拟器（或小型实验）给出结果 -> AI分析结果，调整模型参数 -> 生成更优方案。每一次循环，都是对“解空间”的一次更精确的“收敛”，将“探索的熵”有效降低。John提到的“将数月或数年的试错时间压缩到数天甚至数小时”，正是这种<strong class="key-phrase">“时间尺度压缩”</strong>的体现，其物理意义在于极大地提升了单位时间内有效探索的次数。</p>
                
                <p>最终发现的无PFAS冷却剂，是这个AI驱动的“定向进化”过程的产物。它不仅仅是一个新分子，更是<strong class="key-phrase">“科学发现方法论”</strong>本身的一次进化。这个过程体现了从“经验驱动”到“数据与模型驱动”的转变，科学家的角色也从繁重的重复劳动者，转变为AI协作的“策略制定者”和“最终验证者”。这如同物理学家从用肉眼观测天体，到使用望远镜，再到今天利用复杂的探测器阵列和数据分析算法，每一次工具的革新都带来了认知边界的极大拓展。</p>

                <p>从更宏观的物理逻辑看，Microsoft Discovery平台致力于构建一个<strong class="key-phrase">“科学知识的加速器”</strong>。它通过整合HPC资源、量子计算（未来）、AI模型和自动化流程，试图系统性地降低科学发现的“活化能”，使得更多原本难以企及的科学目标成为可能。这不仅限于新材料，更可应用于药物研发、半导体设计等多个领域，其潜在影响是“普适性”的。</p>

                <p>因此，无PFAS冷却剂的发现，是AI赋能科学研究的一个缩影。它展示了当计算智能达到一定阈值后，如何能够模拟、加速甚至部分替代传统科学探索中的认知与实验过程，从而引发科学产出效率的<strong class="key-phrase">“非线性增长”</strong>。这正是Build 2025所传递的核心信息之一：AI不仅在改变我们与技术交互的方式，更在重塑我们认知和改造物理世界的基本能力。</p>
            </article>
        </section>

        <section class="content-card animation-container">
            <h3 class="text-2xl md:text-3xl font-semibold mb-4">动画1：散热挑战与PFAS困境</h3>
            <p class="text-lg text-gray-700 mb-5">概念动画：展示数据中心组件（如CPU）过热，以及传统PFAS冷却剂的环境风险。</p>
            <div id="problemPfasCanvasWrapper" class="animation-canvas-wrapper shadow-inner"></div>
            <button id="playProblemPfas" class="control-button">播放/重置动画</button>
        </section>

        <section class="content-card animation-container">
            <h3 class="text-2xl md:text-3xl font-semibold mb-4">动画2：Microsoft Discovery 探索流程</h3>
            <p class="text-lg text-gray-700 mb-5">流程动画：简化展示知识图谱构建、AI假设生成、模拟筛选到候选分子的过程。</p>
            <div id="discoveryProcessCanvasWrapper" class="animation-canvas-wrapper shadow-inner"></div>
            <button id="playDiscoveryProcess" class="control-button">播放/重置动画</button>
        </section>

        <section class="content-card animation-container">
            <h3 class="text-2xl md:text-3xl font-semibold mb-4">动画3：AI驱动的分子筛选</h3>
            <p class="text-lg text-gray-700 mb-5">数据/模拟动画：抽象展示大量分子结构被AI快速评估和过滤，少数优质候选者涌现。</p>
            <div id="molecularScreeningCanvasWrapper" class="animation-canvas-wrapper shadow-inner"></div>
            <button id="playMolecularScreening" class="control-button">播放/重置动画</button>
        </section>

        <section class="content-card animation-container">
            <h3 class="text-2xl md:text-3xl font-semibold mb-4">动画4：科学发现的迭代学习加速环</h3>
            <p class="text-lg text-gray-700 mb-5">概念动画：展示“生成-模拟-分析-优化”的AI学习闭环，不断加速逼近目标。</p>
            <div id="iterativeLearningCanvasWrapper" class="animation-canvas-wrapper shadow-inner"></div>
            <button id="playIterativeLearning" class="control-button">播放/重置动画</button>
        </section>

        <section class="content-card animation-container">
            <h3 class="text-2xl md:text-3xl font-semibold mb-4">动画5：新一代冷却方案的诞生</h3>
            <p class="text-lg text-gray-700 mb-5">成果动画：展示新发现的无PFAS冷却剂如何有效冷却组件，并强调其环境友好特性。</p>
            <div id="coolantSolutionCanvasWrapper" class="animation-canvas-wrapper shadow-inner"></div>
            <button id="playCoolantSolution" class="control-button">播放/重置动画</button>
        </section>
        
        <footer class="text-center mt-16 py-8 border-t border-gray-300">
            <p class="text-gray-700">&copy; 2025 微软Discovery平台深度解析。AI驱动科学创新。</p>
            <p class="text-md text-gray-600 mt-2">本文档由AI辅助生成，内容和动画仅供学习与概念演示。</p>
        </footer>
    </div>

    <script>
        // P5.js Sketches and Control Logic for Coolant Discovery Animations

        // Common utility for P5 sketches
        function initializeSketch(sketchFunction, wrapperId, buttonId) {
            let instance;
            document.addEventListener('DOMContentLoaded', () => {
                instance = new p5(sketchFunction, wrapperId);
                document.getElementById(buttonId).addEventListener('click', () => {
                    if (instance && typeof instance.customReset === 'function') {
                        instance.customReset();
                    }
                });
            });
        }

        // Animation 1: Problem - Overheating & PFAS
        const sketchProblemPfas = (p) => {
            let cpuTemp = 30;
            let maxTemp = 100;
            let pfasParticles = [];
            const numPfas = 20;
            let time = 0;
            let stage = 0; // 0: heating, 1: pfas shown
            let isPlaying = false;

            p.setup = () => {
                const wrapper = document.getElementById('problemPfasCanvasWrapper');
                p.createCanvas(wrapper.offsetWidth, wrapper.offsetHeight);
                p.frameRate(30);
                p.customReset();
            };

            p.customReset = () => {
                cpuTemp = 30;
                pfasParticles = [];
                time = 0;
                stage = 0;
                isPlaying = true;
                // p.loop();
                for (let i = 0; i < numPfas; i++) {
                    pfasParticles.push({
                        x: p.random(p.width * 0.6, p.width * 0.9),
                        y: p.random(p.height * 0.1, p.height * 0.9),
                        vx: p.random(-0.5, 0.5),
                        vy: p.random(-0.5, 0.5),
                        size: p.random(8, 15),
                        alpha: 0
                    });
                }
            };
            
            p.draw = () => {
                if (!isPlaying) return;
                p.background(229, 231, 235); // Tailwind gray-200

                time++;
                // Stage 0: CPU heating up
                if (stage === 0) {
                    if (cpuTemp < maxTemp) cpuTemp += 0.5;
                    else stage = 1; // Transition to showing PFAS
                }

                // Draw CPU (simple rectangle)
                let cpuWidth = p.width * 0.3;
                let cpuHeight = p.height * 0.2;
                let cpuX = p.width * 0.15;
                let cpuY = p.height / 2 - cpuHeight / 2;
                let tempColor = p.map(cpuTemp, 30, maxTemp, 0, 255);
                p.fill(tempColor, 50, 50, 200); // Redder as it heats
                p.stroke(50);
                p.rect(cpuX, cpuY, cpuWidth, cpuHeight, 8);
                p.fill(255);
                p.textAlign(p.CENTER, p.CENTER);
                p.textSize(p.min(p.width, p.height) * 0.05);
                p.text(`CPU: ${p.floor(cpuTemp)}°C`, cpuX + cpuWidth / 2, cpuY + cpuHeight / 2);

                // Stage 1: Show PFAS particles as problematic
                if (stage === 1) {
                    p.textSize(p.min(p.width, p.height) * 0.04);
                    p.fill(150,0,0);
                    p.text("传统PFAS冷却剂 (环境风险!)", p.width * 0.75, p.height * 0.1);
                    for (let particle of pfasParticles) {
                        if (particle.alpha < 200) particle.alpha += 5;
                        particle.x += particle.vx;
                        particle.y += particle.vy;
                        if (particle.x < p.width * 0.55 || particle.x > p.width * 0.95) particle.vx *= -1;
                        if (particle.y < p.height * 0.15 || particle.y > p.height * 0.85) particle.vy *= -1;
                        
                        p.fill(220, 50, 50, particle.alpha); // Red, spiky-like
                        p.noStroke();
                        p.beginShape();
                        for (let i = 0; i < 5; i++) {
                            let angle = p.TWO_PI / 5 * i;
                            let r1 = particle.size / 2;
                            let r2 = particle.size;
                            p.vertex(particle.x + p.cos(angle) * r2, particle.y + p.sin(angle) * r2);
                            angle += p.TWO_PI / 10;
                            p.vertex(particle.x + p.cos(angle) * r1, particle.y + p.sin(angle) * r1);
                        }
                        p.endShape(p.CLOSE);
                    }
                }
                if (time > 600) { // Stop animation after a while
                    // isPlaying = false; 
                    // p.noLoop();
                }
            };
            p.windowResized = () => {
                const wrapper = document.getElementById('problemPfasCanvasWrapper');
                p.resizeCanvas(wrapper.offsetWidth, wrapper.offsetHeight);
                p.customReset();
            };
        };
        initializeSketch(sketchProblemPfas, 'problemPfasCanvasWrapper', 'playProblemPfas');

        // Animation 2: Microsoft Discovery Process Flow
        const sketchDiscoveryProcess = (p) => {
            let stages = [
                { name: "知识图谱构建\n(GraphRAG)", x: 0, y: 0, w:0, h:0, active: false, progress: 0},
                { name: "AI假设生成\n(数百万候选)", x: 0, y: 0, w:0, h:0, active: false, progress: 0},
                { name: "智能模拟筛选", x: 0, y: 0, w:0, h:0, active: false, progress: 0},
                { name: "优质候选输出", x: 0, y: 0, w:0, h:0, active: false, progress: 0}
            ];
            let currentStage = -1;
            let time = 0;
            let isPlaying = false;

            p.setup = () => {
                const wrapper = document.getElementById('discoveryProcessCanvasWrapper');
                p.createCanvas(wrapper.offsetWidth, wrapper.offsetHeight);
                p.frameRate(30);
                p.customReset();
            };

            p.customReset = () => {
                currentStage = -1;
                time = 0;
                isPlaying = true;
                // p.loop();
                stages.forEach(s => { s.active = false; s.progress = 0; });
                let stageWidth = p.width * 0.22;
                let stageHeight = p.height * 0.4;
                let spacing = (p.width - stages.length * stageWidth) / (stages.length + 1);
                for(let i=0; i<stages.length; i++) {
                    stages[i].x = spacing * (i+1) + stageWidth * i;
                    stages[i].y = p.height/2 - stageHeight/2;
                    stages[i].w = stageWidth;
                    stages[i].h = stageHeight;
                }
            };

            p.draw = () => {
                if (!isPlaying) return;
                p.background(229, 231, 235);
                time++;

                if (time % 60 === 0 && currentStage < stages.length -1) {
                    currentStage++;
                    stages[currentStage].active = true;
                }

                p.textAlign(p.CENTER, p.CENTER);
                p.textSize(p.min(p.width,p.height) * 0.035);

                for (let i = 0; i < stages.length; i++) {
                    let s = stages[i];
                    if (s.active && s.progress < 1) s.progress += 0.05;
                    
                    p.fill(s.active ? p.color(59, 130, 246, 200) : p.color(156, 163, 175, 150)); // Blue when active
                    p.stroke(50);
                    p.rect(s.x, s.y, s.w * s.progress, s.h * s.progress, 8);
                    
                    if (s.progress > 0.8) {
                        p.fill(s.active ? 255 : 50);
                        p.text(s.name, s.x + (s.w * s.progress) / 2, s.y + (s.h * s.progress) / 2);
                    }

                    // Draw arrows
                    if (i < stages.length - 1 && stages[i+1].active) {
                        p.stroke(50, 50, 150, 150);
                        p.strokeWeight(3);
                        p.line(s.x + s.w * s.progress, s.y + s.h/2, stages[i+1].x, stages[i+1].y + stages[i+1].h/2);
                        // Arrowhead
                        p.push();
                        p.translate(stages[i+1].x, stages[i+1].y + stages[i+1].h/2);
                        p.fill(50, 50, 150, 150);
                        p.triangle(-10, -5, -10, 5, 0, 0);
                        p.pop();
                    }
                }
                 if (currentStage === stages.length -1 && stages[currentStage].progress >= 1) {
                    // isPlaying = false;
                    // p.noLoop();
                }
            };
             p.windowResized = () => {
                const wrapper = document.getElementById('discoveryProcessCanvasWrapper');
                p.resizeCanvas(wrapper.offsetWidth, wrapper.offsetHeight);
                p.customReset();
            };
        };
        initializeSketch(sketchDiscoveryProcess, 'discoveryProcessCanvasWrapper', 'playDiscoveryProcess');

        // Animation 3: Molecular Screening
        const sketchMolecularScreening = (p) => {
            let molecules = [];
            const numMolecules = 100;
            let filterPos;
            let filterWidth;
            let screenedMolecules = 0;
            let time = 0;
            let isPlaying = false;

            p.setup = () => {
                const wrapper = document.getElementById('molecularScreeningCanvasWrapper');
                p.createCanvas(wrapper.offsetWidth, wrapper.offsetHeight);
                filterPos = p.width * 0.6;
                filterWidth = p.width * 0.05;
                p.frameRate(30);
                p.customReset();
            };

            p.customReset = () => {
                molecules = [];
                screenedMolecules = 0;
                time = 0;
                isPlaying = true;
                // p.loop();
                for (let i = 0; i < numMolecules; i++) {
                    molecules.push({
                        x: p.random(-p.width * 0.5, p.width * 0.4), // Start off-screen left or spread out
                        y: p.random(p.height * 0.1, p.height * 0.9),
                        vx: p.random(1, 3),
                        size: p.random(5, 10),
                        color: p.color(p.random(100,200), p.random(100,200), p.random(200,255), 180),
                        isGood: p.random() > 0.9, // 10% are "good"
                        passedFilter: false
                    });
                }
            };

            p.draw = () => {
                if (!isPlaying) return;
                p.background(229, 231, 235);
                time++;

                // Draw AI Filter
                p.fill(75, 85, 99, 150); // Gray filter
                p.noStroke();
                p.rect(filterPos - filterWidth/2, 0, filterWidth, p.height);
                p.fill(255);
                p.textAlign(p.CENTER, p.CENTER);
                p.textSize(p.min(p.width,p.height)*0.04);
                p.push();
                p.translate(filterPos, p.height/2);
                p.rotate(-p.HALF_PI);
                p.text("AI 筛选器", 0, 0);
                p.pop();

                // Update and draw molecules
                for (let m of molecules) {
                    m.x += m.vx;
                    p.fill(m.color);
                    p.noStroke();
                    p.ellipse(m.x, m.y, m.size, m.size);

                    // Check for passing filter
                    if (!m.passedFilter && m.x > filterPos) {
                        if (m.isGood) {
                            m.passedFilter = true;
                            m.vx = p.random(0.5, 1.5); // Slow down after passing
                            m.color = p.color(50, 200, 50, 220); // Turn green
                            screenedMolecules++;
                        } else {
                            // Bounce bad molecules or make them disappear
                            m.vx *= -0.5; 
                            m.x = filterPos - m.size; // Push back slightly
                            m.color = p.color(200,50,50,100); // Fade to red
                        }
                    }
                    // Remove molecules that go too far off screen
                    if (m.x > p.width + 20 || m.x < -p.width*0.5 - 20) {
                         // Reset if needed, or just let them go
                    }
                }
                
                p.fill(0);
                p.textSize(p.min(p.width,p.height)*0.05);
                p.textAlign(p.RIGHT);
                p.text(`优质候选: ${screenedMolecules}`, p.width - 20, p.height - 30);

                if (time > 800 || screenedMolecules > numMolecules * 0.09) {
                    // isPlaying = false;
                    // p.noLoop();
                }
            };
             p.windowResized = () => {
                const wrapper = document.getElementById('molecularScreeningCanvasWrapper');
                p.resizeCanvas(wrapper.offsetWidth, wrapper.offsetHeight);
                filterPos = p.width * 0.6;
                filterWidth = p.width * 0.05;
                p.customReset();
            };
        };
        initializeSketch(sketchMolecularScreening, 'molecularScreeningCanvasWrapper', 'playMolecularScreening');

        // Animation 4: Iterative Learning Loop
        const sketchIterativeLearning = (p) => {
            let angle = 0;
            let radius;
            let points = ["生成", "模拟", "分析", "优化"];
            let currentPoint = 0;
            let particlePos;
            let isPlaying = false;

            p.setup = () => {
                const wrapper = document.getElementById('iterativeLearningCanvasWrapper');
                p.createCanvas(wrapper.offsetWidth, wrapper.offsetHeight);
                radius = p.min(p.width, p.height) * 0.3;
                p.frameRate(30);
                p.customReset();
            };
            
            p.customReset = () => {
                angle = -p.HALF_PI; // Start at the top
                currentPoint = 0;
                isPlaying = true;
                // p.loop();
                particlePos = p.createVector(p.width/2 + p.cos(angle) * radius, p.height/2 + p.sin(angle) * radius);
            };

            p.draw = () => {
                if (!isPlaying) return;
                p.background(229, 231, 235);
                p.translate(p.width / 2, p.height / 2);

                // Draw loop circle and points
                p.stroke(107, 114, 128, 150); // Gray circle
                p.strokeWeight(2);
                p.noFill();
                p.ellipse(0, 0, radius * 2, radius * 2);

                p.textAlign(p.CENTER, p.CENTER);
                p.textSize(p.min(p.width,p.height)*0.04);
                for (let i = 0; i < points.length; i++) {
                    let a = p.TWO_PI / points.length * i - p.HALF_PI;
                    let x = p.cos(a) * radius;
                    let y = p.sin(a) * radius;
                    p.fill(i === currentPoint ? p.color(37, 99, 235) : p.color(55, 65, 81)); // Blue for current
                    p.noStroke();
                    p.ellipse(x, y, p.min(p.width,p.height)*0.1, p.min(p.width,p.height)*0.1);
                    p.fill(255);
                    p.text(points[i], x, y);
                }

                // Animate particle along the loop
                angle += 0.03;
                if (angle > p.TWO_PI - p.HALF_PI) { // Reset angle to loop
                    angle = -p.HALF_PI;
                }
                particlePos.x = p.cos(angle) * radius;
                particlePos.y = p.sin(angle) * radius;
                
                p.fill(234, 88, 12); // Orange particle
                p.noStroke();
                p.ellipse(particlePos.x, particlePos.y, 20, 20);

                // Update current point based on particle position
                let particleAngleNormalized = (angle + p.HALF_PI + p.TWO_PI) % p.TWO_PI; // Normalize angle to 0 - 2PI
                currentPoint = p.floor(particleAngleNormalized / (p.TWO_PI / points.length)) % points.length;

                // Draw arrowheads on the circle
                for (let i = 0; i < 8; i++) { // Draw 8 arrowheads
                    let arrowAngle = p.TWO_PI / 8 * i + angle * 0.1; // Rotate slightly with main angle
                    p.push();
                    p.translate(p.cos(arrowAngle) * radius, p.sin(arrowAngle) * radius);
                    p.rotate(arrowAngle + p.HALF_PI);
                    p.fill(107, 114, 128);
                    p.triangle(-5, 5, 5, 5, 0, -5);
                    p.pop();
                }
                 if (angle > p.TWO_PI * 3 - p.HALF_PI) { // Let it run for 3 loops then pause
                    // isPlaying = false;
                    // p.noLoop();
                }
            };
            p.windowResized = () => {
                const wrapper = document.getElementById('iterativeLearningCanvasWrapper');
                p.resizeCanvas(wrapper.offsetWidth, wrapper.offsetHeight);
                radius = p.min(p.width, p.height) * 0.3;
                p.customReset();
            };
        };
        initializeSketch(sketchIterativeLearning, 'iterativeLearningCanvasWrapper', 'playIterativeLearning');

        // Animation 5: Coolant Solution
        const sketchCoolantSolution = (p) => {
            let cpuTemp = 95;
            let targetTemp = 35;
            let coolantLevel = 0; // 0 to 1
            let bubbles = [];
            let isPlaying = false;
            let time = 0;

            p.setup = () => {
                const wrapper = document.getElementById('coolantSolutionCanvasWrapper');
                p.createCanvas(wrapper.offsetWidth, wrapper.offsetHeight);
                p.frameRate(30);
                p.customReset();
            };
            
            p.customReset = () => {
                cpuTemp = 95;
                coolantLevel = 0;
                bubbles = [];
                time = 0;
                isPlaying = true;
                // p.loop();
            };

            p.draw = () => {
                if (!isPlaying) return;
                p.background(229, 231, 235);
                time++;

                // CPU
                let cpuWidth = p.width * 0.25;
                let cpuHeight = p.height * 0.5;
                let cpuX = p.width / 2 - cpuWidth / 2;
                let cpuY = p.height * 0.4 - cpuHeight / 2;
                
                // Coolant filling up
                if (coolantLevel < 1) {
                    coolantLevel += 0.005;
                } else {
                    if (cpuTemp > targetTemp) {
                        cpuTemp -= 0.3;
                    }
                }
                cpuTemp = p.max(cpuTemp, targetTemp);

                // Draw coolant
                p.fill(100, 180, 255, 150); // Light blue coolant
                p.noStroke();
                let currentCoolantHeight = p.height * coolantLevel;
                p.rect(0, p.height - currentCoolantHeight, p.width, currentCoolantHeight);

                // Draw CPU
                let tempColor = p.map(cpuTemp, targetTemp, 95, 0, 255);
                p.fill(tempColor, 100, 100, 220);
                p.stroke(50);
                p.rect(cpuX, cpuY, cpuWidth, cpuHeight, 8);
                p.fill(255);
                p.textAlign(p.CENTER, p.CENTER);
                p.textSize(p.min(p.width,p.height)*0.05);
                p.text(`${p.floor(cpuTemp)}°C`, cpuX + cpuWidth / 2, cpuY + cpuHeight / 2);

                // Bubbles if cooling
                if (coolantLevel > 0.5 && cpuTemp > targetTemp + 5 && p.random() < 0.3) {
                    bubbles.push({
                        x: cpuX + p.random(cpuWidth),
                        y: cpuY + p.random(cpuHeight),
                        size: p.random(2, 5),
                        life: 100
                    });
                }
                for (let i = bubbles.length - 1; i >= 0; i--) {
                    let b = bubbles[i];
                    b.y -= p.random(0.5, 1.5);
                    b.life -= 2;
                    p.fill(200, 220, 255, b.life);
                    p.noStroke();
                    p.ellipse(b.x, b.y, b.size, b.size);
                    if (b.life <= 0 || b.y < p.height - currentCoolantHeight) {
                        bubbles.splice(i, 1);
                    }
                }
                
                // Environment friendly icon/text
                if (cpuTemp <= targetTemp + 5 && coolantLevel >=1) {
                    p.fill(34, 139, 34, 200); // ForestGreen
                    p.textSize(p.min(p.width,p.height)*0.06);
                    // Simple leaf shape
                    p.beginShape();
                    p.vertex(p.width * 0.8, p.height * 0.2);
                    p.bezierVertex(p.width * 0.75, p.height * 0.1, p.width * 0.7, p.height * 0.25, p.width * 0.8, p.height * 0.4);
                    p.bezierVertex(p.width * 0.9, p.height * 0.25, p.width * 0.85, p.height * 0.1, p.width * 0.8, p.height * 0.2);
                    p.endShape(p.CLOSE);
                    p.fill(0);
                    p.textSize(p.min(p.width,p.height)*0.04);
                    p.text("环境友好!", p.width * 0.8, p.height * 0.5);
                }


                if (time > 1200) { // Stop after a longer duration
                    // isPlaying = false;
                    // p.noLoop();
                }
            };
            p.windowResized = () => {
                const wrapper = document.getElementById('coolantSolutionCanvasWrapper');
                p.resizeCanvas(wrapper.offsetWidth, wrapper.offsetHeight);
                p.customReset();
            };
        };
        initializeSketch(sketchCoolantSolution, 'coolantSolutionCanvasWrapper', 'playCoolantSolution');
        
    </script>
    </body>
</html>
